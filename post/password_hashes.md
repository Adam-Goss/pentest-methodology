# Leveraging Password Hashes

### Retrieving Password Hashes 

Identifying hashes:
- to identify a hash type you can use the **hashid** tool 
- i.e. `hashid <hash>`
- this will return the possible hash formats the supplied hash matches with, which can then be used to help with password cracking
- you can also use online tools to identify hashes

Linux systems:
- in most Linux system password hashes are stored in the `/etc/shadow` file, which requires root permissions to read
- i.e. `sudo cat /etc/shadow`
- once you compromise a system, and obtain root privileges, it can be useful to pillage this file and try to crack password hashes as many users will use the same password in multiple places

Windows systems:
- Windows hashes are stored in the SAM database, which cannot be accessed while the OS is running
- **mimikatz** is a tool that can be used to mount in-memory attacks designed to dump the SAM hashes 
- it's modules facilitate password hash extraction from the Local Security Authority Subsystem (LSASS) process memory where they are cached 
- since LSASS is a privileged process running under the SYSTEM user, you must launch `mimikatz` from an adminsistrative command prompt 
- to extract password hashes, you must first execute two commands:
	- a) `privilege::debug` to enable the SeDebugPrivilege access right required to tamper with another process 
	- b) `token::elevate` to elevate the security token from high integrity (administrator) to SYSTEM integrity (if mimikatz is launched from a SYSTEM shell, this step is not required)
- then you can use `lsadump::sam` to dump the contents of the SAM database
- i.e. in a Windows shell: `mimikatz.exe` -> `privilege::debug` -> `token::elevate` -> `lsadump::sam`



<br>

### Passing the Hash in Windows

> Pass-the-Hash (PtH) allows an attacker to authenticate to a remote target by using a valid combination of username and NTLM/LM hash rather than a clear text password. This is because NTLM/LM hashes are not salted and remain static between sessions. If you discover a password hash on one target, you can use it to authenticate against that target as well as other targets if that account uses the same username and password. 

- if you have exploited one Windows system, gained SYSTEM privileges, and dumped the local LM and NTLM hashes, you can copy the local administrator NTLM hash and use it instead of a password to gain access to a different machine (if that machine has the same local administrator account and password)
- you can use the tool **pth-winexe** from the Passing-The-Hash toolkit (a modified version of winexe), to perform authentication using the SMB protocol and gain a shell on the target using captured hash credentials
- usage: `pth-winexe -U <username>%<hash> //<host> <command>`
- i.e. `pth-winexe -U offsec%aad3b435b51404eeaad3b435b51404ee:2892d26cdf84d7a70e2eb3b9f05c425e  /10.11.0.22 cmd`
- behind the scenes, the format of the NTLM hash we provided was changed into a NetNTLM version 1 or 2 format during the authentication process. You can capture these hashes using man-in-the-middle or poisoning attacks and either crack them or relay them.
- for example, you can to poison Web Proxy Auto-Discovery Protocol (WPAD) requests (coming from Internet Explorer or Windows Defender) or SMB requests to force NetNTLM with a tool like **Responder.py** and capture these hashes to then reuse 


<br>

### Password Cracking 

Windows NT hashes John:
- to crack a Windows NT hash: `john --wordlist=<wordlists> <hash>.txt --format=NT`
- i.e. `john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt --format=NT`
- to apply John's word mangling option (if passwords remain to be cracked): `john --rules --wordlist=/usr/share/wordlists/rockyou.txt hash.txt --format=NT`

Linux-based hashes with John:
- a) use `unshadow` utility to combine the `/etc/passwd` and `/etc/shadow` files from the compromised system
	- i.e. `unshadow passwd-file.txt shadow-file.txt > unshadowed.txt`
- b) crack with John
	- i.e. `john --rules --wordlist=/usr/share/wordlists/rockyou.txt unshadowed.txt`

